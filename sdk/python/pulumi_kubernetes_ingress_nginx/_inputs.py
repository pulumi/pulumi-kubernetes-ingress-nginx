# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
import pulumi_kubernetes

__all__ = [
    'AutoscalingBehaviorScalingPolicyArgs',
    'AutoscalingBehaviorScalingPolicyArgsDict',
    'AutoscalingBehaviorScalingArgs',
    'AutoscalingBehaviorScalingArgsDict',
    'AutoscalingBehaviorArgs',
    'AutoscalingBehaviorArgsDict',
    'AutoscalingTemplatePodsMetricArgs',
    'AutoscalingTemplatePodsMetricArgsDict',
    'AutoscalingTemplatePodsTargetArgs',
    'AutoscalingTemplatePodsTargetArgsDict',
    'AutoscalingTemplatePodsArgs',
    'AutoscalingTemplatePodsArgsDict',
    'AutoscalingTemplateArgs',
    'AutoscalingTemplateArgsDict',
    'AutoscalingArgs',
    'AutoscalingArgsDict',
    'ContollerAdmissionWebhooksArgs',
    'ContollerAdmissionWebhooksArgsDict',
    'ControllerAdmissionWebhooksCreateSecretJobArgs',
    'ControllerAdmissionWebhooksCreateSecretJobArgsDict',
    'ControllerAdmissionWebhooksPatchWebhbookJobArgs',
    'ControllerAdmissionWebhooksPatchWebhbookJobArgsDict',
    'ControllerAdmissionWebhooksPatchArgs',
    'ControllerAdmissionWebhooksPatchArgsDict',
    'ControllerAdmissionWebhooksServiceArgs',
    'ControllerAdmissionWebhooksServiceArgsDict',
    'ControllerCustomTemplateArgs',
    'ControllerCustomTemplateArgsDict',
    'ControllerDefaultBackendServiceArgs',
    'ControllerDefaultBackendServiceArgsDict',
    'ControllerDefaultBackendArgs',
    'ControllerDefaultBackendArgsDict',
    'ControllerHostPortPortsArgs',
    'ControllerHostPortPortsArgsDict',
    'ControllerHostPortArgs',
    'ControllerHostPortArgsDict',
    'ControllerImageArgs',
    'ControllerImageArgsDict',
    'ControllerIngressClassResourceArgs',
    'ControllerIngressClassResourceArgsDict',
    'ControllerMetricsPrometheusRulesArgs',
    'ControllerMetricsPrometheusRulesArgsDict',
    'ControllerMetricsServiceMonitorArgs',
    'ControllerMetricsServiceMonitorArgsDict',
    'ControllerMetricsServiceArgs',
    'ControllerMetricsServiceArgsDict',
    'ControllerMetricsArgs',
    'ControllerMetricsArgsDict',
    'ControllerPodSecurityPolicyArgs',
    'ControllerPodSecurityPolicyArgsDict',
    'ControllerPortArgs',
    'ControllerPortArgsDict',
    'ControllerPublishServiceArgs',
    'ControllerPublishServiceArgsDict',
    'ControllerRBACArgs',
    'ControllerRBACArgsDict',
    'ControllerRollingUpdateArgs',
    'ControllerRollingUpdateArgsDict',
    'ControllerScopeArgs',
    'ControllerScopeArgsDict',
    'ControllerServiceAccountArgs',
    'ControllerServiceAccountArgsDict',
    'ControllerServiceInternalArgs',
    'ControllerServiceInternalArgsDict',
    'ControllerServiceNodePortsArgs',
    'ControllerServiceNodePortsArgsDict',
    'ControllerServiceArgs',
    'ControllerServiceArgsDict',
    'ControllerTcpArgs',
    'ControllerTcpArgsDict',
    'ControllerUdpArgs',
    'ControllerUdpArgsDict',
    'ControllerUpdateStrategyArgs',
    'ControllerUpdateStrategyArgsDict',
    'ControllerArgs',
    'ControllerArgsDict',
    'KedaScaledObjectArgs',
    'KedaScaledObjectArgsDict',
    'KedaTriggerArgs',
    'KedaTriggerArgsDict',
    'KedaArgs',
    'KedaArgsDict',
    'ReleaseArgs',
    'ReleaseArgsDict',
    'RepositoryOptsArgs',
    'RepositoryOptsArgsDict',
]

MYPY = False

if not MYPY:
    class AutoscalingBehaviorScalingPolicyArgsDict(TypedDict):
        period_seconds: NotRequired[pulumi.Input[builtins.int]]
        type: NotRequired[pulumi.Input[builtins.str]]
        value: NotRequired[pulumi.Input[builtins.int]]
elif False:
    AutoscalingBehaviorScalingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalingBehaviorScalingPolicyArgs:
    def __init__(__self__, *,
                 period_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.int]] = None):
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AutoscalingBehaviorScalingArgsDict(TypedDict):
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutoscalingBehaviorScalingPolicyArgsDict']]]]
        stabilization_window_seconds: NotRequired[pulumi.Input[builtins.int]]
elif False:
    AutoscalingBehaviorScalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalingBehaviorScalingArgs:
    def __init__(__self__, *,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingBehaviorScalingPolicyArgs']]]] = None,
                 stabilization_window_seconds: Optional[pulumi.Input[builtins.int]] = None):
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if stabilization_window_seconds is not None:
            pulumi.set(__self__, "stabilization_window_seconds", stabilization_window_seconds)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingBehaviorScalingPolicyArgs']]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingBehaviorScalingPolicyArgs']]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter(name="stabilizationWindowSeconds")
    def stabilization_window_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "stabilization_window_seconds")

    @stabilization_window_seconds.setter
    def stabilization_window_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "stabilization_window_seconds", value)


if not MYPY:
    class AutoscalingBehaviorArgsDict(TypedDict):
        scale_down: NotRequired[pulumi.Input['AutoscalingBehaviorScalingArgsDict']]
        scale_up: NotRequired[pulumi.Input['AutoscalingBehaviorScalingArgsDict']]
elif False:
    AutoscalingBehaviorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalingBehaviorArgs:
    def __init__(__self__, *,
                 scale_down: Optional[pulumi.Input['AutoscalingBehaviorScalingArgs']] = None,
                 scale_up: Optional[pulumi.Input['AutoscalingBehaviorScalingArgs']] = None):
        if scale_down is not None:
            pulumi.set(__self__, "scale_down", scale_down)
        if scale_up is not None:
            pulumi.set(__self__, "scale_up", scale_up)

    @property
    @pulumi.getter(name="scaleDown")
    def scale_down(self) -> Optional[pulumi.Input['AutoscalingBehaviorScalingArgs']]:
        return pulumi.get(self, "scale_down")

    @scale_down.setter
    def scale_down(self, value: Optional[pulumi.Input['AutoscalingBehaviorScalingArgs']]):
        pulumi.set(self, "scale_down", value)

    @property
    @pulumi.getter(name="scaleUp")
    def scale_up(self) -> Optional[pulumi.Input['AutoscalingBehaviorScalingArgs']]:
        return pulumi.get(self, "scale_up")

    @scale_up.setter
    def scale_up(self, value: Optional[pulumi.Input['AutoscalingBehaviorScalingArgs']]):
        pulumi.set(self, "scale_up", value)


if not MYPY:
    class AutoscalingTemplatePodsMetricArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    AutoscalingTemplatePodsMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalingTemplatePodsMetricArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AutoscalingTemplatePodsTargetArgsDict(TypedDict):
        average_value: NotRequired[pulumi.Input[builtins.str]]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    AutoscalingTemplatePodsTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalingTemplatePodsTargetArgs:
    def __init__(__self__, *,
                 average_value: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        if average_value is not None:
            pulumi.set(__self__, "average_value", average_value)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="averageValue")
    def average_value(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "average_value")

    @average_value.setter
    def average_value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "average_value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AutoscalingTemplatePodsArgsDict(TypedDict):
        metric: NotRequired[pulumi.Input['AutoscalingTemplatePodsMetricArgsDict']]
        target: NotRequired[pulumi.Input['AutoscalingTemplatePodsTargetArgsDict']]
elif False:
    AutoscalingTemplatePodsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalingTemplatePodsArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input['AutoscalingTemplatePodsMetricArgs']] = None,
                 target: Optional[pulumi.Input['AutoscalingTemplatePodsTargetArgs']] = None):
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input['AutoscalingTemplatePodsMetricArgs']]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input['AutoscalingTemplatePodsMetricArgs']]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['AutoscalingTemplatePodsTargetArgs']]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['AutoscalingTemplatePodsTargetArgs']]):
        pulumi.set(self, "target", value)


if not MYPY:
    class AutoscalingTemplateArgsDict(TypedDict):
        pods: NotRequired[pulumi.Input['AutoscalingTemplatePodsArgsDict']]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    AutoscalingTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalingTemplateArgs:
    def __init__(__self__, *,
                 pods: Optional[pulumi.Input['AutoscalingTemplatePodsArgs']] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        if pods is not None:
            pulumi.set(__self__, "pods", pods)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def pods(self) -> Optional[pulumi.Input['AutoscalingTemplatePodsArgs']]:
        return pulumi.get(self, "pods")

    @pods.setter
    def pods(self, value: Optional[pulumi.Input['AutoscalingTemplatePodsArgs']]):
        pulumi.set(self, "pods", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AutoscalingArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        controller_autoscaling_behavior: NotRequired[pulumi.Input['AutoscalingBehaviorArgsDict']]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        max_replicas: NotRequired[pulumi.Input[builtins.int]]
        min_replicas: NotRequired[pulumi.Input[builtins.int]]
        target_cpu_utilization_percentage: NotRequired[pulumi.Input[builtins.int]]
        target_memory_utilization_percentage: NotRequired[pulumi.Input[builtins.int]]
elif False:
    AutoscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscalingArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 controller_autoscaling_behavior: Optional[pulumi.Input['AutoscalingBehaviorArgs']] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 max_replicas: Optional[pulumi.Input[builtins.int]] = None,
                 min_replicas: Optional[pulumi.Input[builtins.int]] = None,
                 target_cpu_utilization_percentage: Optional[pulumi.Input[builtins.int]] = None,
                 target_memory_utilization_percentage: Optional[pulumi.Input[builtins.int]] = None):
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if controller_autoscaling_behavior is not None:
            pulumi.set(__self__, "controller_autoscaling_behavior", controller_autoscaling_behavior)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_replicas is not None:
            pulumi.set(__self__, "max_replicas", max_replicas)
        if min_replicas is not None:
            pulumi.set(__self__, "min_replicas", min_replicas)
        if target_cpu_utilization_percentage is not None:
            pulumi.set(__self__, "target_cpu_utilization_percentage", target_cpu_utilization_percentage)
        if target_memory_utilization_percentage is not None:
            pulumi.set(__self__, "target_memory_utilization_percentage", target_memory_utilization_percentage)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="controllerAutoscalingBehavior")
    def controller_autoscaling_behavior(self) -> Optional[pulumi.Input['AutoscalingBehaviorArgs']]:
        return pulumi.get(self, "controller_autoscaling_behavior")

    @controller_autoscaling_behavior.setter
    def controller_autoscaling_behavior(self, value: Optional[pulumi.Input['AutoscalingBehaviorArgs']]):
        pulumi.set(self, "controller_autoscaling_behavior", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max_replicas")

    @max_replicas.setter
    def max_replicas(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_replicas", value)

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "min_replicas")

    @min_replicas.setter
    def min_replicas(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_replicas", value)

    @property
    @pulumi.getter(name="targetCPUUtilizationPercentage")
    def target_cpu_utilization_percentage(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "target_cpu_utilization_percentage")

    @target_cpu_utilization_percentage.setter
    def target_cpu_utilization_percentage(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "target_cpu_utilization_percentage", value)

    @property
    @pulumi.getter(name="targetMemoryUtilizationPercentage")
    def target_memory_utilization_percentage(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "target_memory_utilization_percentage")

    @target_memory_utilization_percentage.setter
    def target_memory_utilization_percentage(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "target_memory_utilization_percentage", value)


if not MYPY:
    class ContollerAdmissionWebhooksArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        certificate: NotRequired[pulumi.Input[builtins.str]]
        create_secret_job: NotRequired[pulumi.Input['ControllerAdmissionWebhooksCreateSecretJobArgsDict']]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        existing_psp: NotRequired[pulumi.Input[builtins.str]]
        """
        Use an existing PSP instead of creating one.
        """
        failure_policy: NotRequired[pulumi.Input[builtins.str]]
        key: NotRequired[pulumi.Input[builtins.str]]
        namespace_selector: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]
        object_selector: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]
        patch: NotRequired[pulumi.Input['ControllerAdmissionWebhooksPatchArgsDict']]
        patch_webhook_job: NotRequired[pulumi.Input['ControllerAdmissionWebhooksPatchWebhbookJobArgsDict']]
        port: NotRequired[pulumi.Input[builtins.int]]
        service: NotRequired[pulumi.Input['ControllerAdmissionWebhooksServiceArgsDict']]
        timeout_seconds: NotRequired[pulumi.Input[builtins.int]]
elif False:
    ContollerAdmissionWebhooksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContollerAdmissionWebhooksArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 certificate: Optional[pulumi.Input[builtins.str]] = None,
                 create_secret_job: Optional[pulumi.Input['ControllerAdmissionWebhooksCreateSecretJobArgs']] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 existing_psp: Optional[pulumi.Input[builtins.str]] = None,
                 failure_policy: Optional[pulumi.Input[builtins.str]] = None,
                 key: Optional[pulumi.Input[builtins.str]] = None,
                 namespace_selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]] = None,
                 object_selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]] = None,
                 patch: Optional[pulumi.Input['ControllerAdmissionWebhooksPatchArgs']] = None,
                 patch_webhook_job: Optional[pulumi.Input['ControllerAdmissionWebhooksPatchWebhbookJobArgs']] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 service: Optional[pulumi.Input['ControllerAdmissionWebhooksServiceArgs']] = None,
                 timeout_seconds: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] existing_psp: Use an existing PSP instead of creating one.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if create_secret_job is not None:
            pulumi.set(__self__, "create_secret_job", create_secret_job)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if existing_psp is not None:
            pulumi.set(__self__, "existing_psp", existing_psp)
        if failure_policy is not None:
            pulumi.set(__self__, "failure_policy", failure_policy)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace_selector is not None:
            pulumi.set(__self__, "namespace_selector", namespace_selector)
        if object_selector is not None:
            pulumi.set(__self__, "object_selector", object_selector)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)
        if patch_webhook_job is not None:
            pulumi.set(__self__, "patch_webhook_job", patch_webhook_job)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="createSecretJob")
    def create_secret_job(self) -> Optional[pulumi.Input['ControllerAdmissionWebhooksCreateSecretJobArgs']]:
        return pulumi.get(self, "create_secret_job")

    @create_secret_job.setter
    def create_secret_job(self, value: Optional[pulumi.Input['ControllerAdmissionWebhooksCreateSecretJobArgs']]):
        pulumi.set(self, "create_secret_job", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="existingPsp")
    def existing_psp(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Use an existing PSP instead of creating one.
        """
        return pulumi.get(self, "existing_psp")

    @existing_psp.setter
    def existing_psp(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "existing_psp", value)

    @property
    @pulumi.getter(name="failurePolicy")
    def failure_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "failure_policy")

    @failure_policy.setter
    def failure_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "failure_policy", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="namespaceSelector")
    def namespace_selector(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]:
        return pulumi.get(self, "namespace_selector")

    @namespace_selector.setter
    def namespace_selector(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]):
        pulumi.set(self, "namespace_selector", value)

    @property
    @pulumi.getter(name="objectSelector")
    def object_selector(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]:
        return pulumi.get(self, "object_selector")

    @object_selector.setter
    def object_selector(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]):
        pulumi.set(self, "object_selector", value)

    @property
    @pulumi.getter
    def patch(self) -> Optional[pulumi.Input['ControllerAdmissionWebhooksPatchArgs']]:
        return pulumi.get(self, "patch")

    @patch.setter
    def patch(self, value: Optional[pulumi.Input['ControllerAdmissionWebhooksPatchArgs']]):
        pulumi.set(self, "patch", value)

    @property
    @pulumi.getter(name="patchWebhookJob")
    def patch_webhook_job(self) -> Optional[pulumi.Input['ControllerAdmissionWebhooksPatchWebhbookJobArgs']]:
        return pulumi.get(self, "patch_webhook_job")

    @patch_webhook_job.setter
    def patch_webhook_job(self, value: Optional[pulumi.Input['ControllerAdmissionWebhooksPatchWebhbookJobArgs']]):
        pulumi.set(self, "patch_webhook_job", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input['ControllerAdmissionWebhooksServiceArgs']]:
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input['ControllerAdmissionWebhooksServiceArgs']]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class ControllerAdmissionWebhooksCreateSecretJobArgsDict(TypedDict):
        resources: NotRequired[pulumi.Input['pulumi_kubernetes.core.v1.ResourceRequirementsArgsDict']]
elif False:
    ControllerAdmissionWebhooksCreateSecretJobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerAdmissionWebhooksCreateSecretJobArgs:
    def __init__(__self__, *,
                 resources: Optional[pulumi.Input['pulumi_kubernetes.core.v1.ResourceRequirementsArgs']] = None):
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['pulumi_kubernetes.core.v1.ResourceRequirementsArgs']]:
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['pulumi_kubernetes.core.v1.ResourceRequirementsArgs']]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class ControllerAdmissionWebhooksPatchWebhbookJobArgsDict(TypedDict):
        resources: NotRequired[pulumi.Input['pulumi_kubernetes.core.v1.ResourceRequirementsArgsDict']]
elif False:
    ControllerAdmissionWebhooksPatchWebhbookJobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerAdmissionWebhooksPatchWebhbookJobArgs:
    def __init__(__self__, *,
                 resources: Optional[pulumi.Input['pulumi_kubernetes.core.v1.ResourceRequirementsArgs']] = None):
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['pulumi_kubernetes.core.v1.ResourceRequirementsArgs']]:
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['pulumi_kubernetes.core.v1.ResourceRequirementsArgs']]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class ControllerAdmissionWebhooksPatchArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        image: NotRequired[pulumi.Input['ControllerImageArgsDict']]
        node_selector: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        pod_annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        priority_class_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Provide a priority class name to the webhook patching job.
        """
        run_as_user: NotRequired[pulumi.Input[builtins.int]]
        tolerations: NotRequired[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.TolerationArgsDict']]]]
elif False:
    ControllerAdmissionWebhooksPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerAdmissionWebhooksPatchArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 image: Optional[pulumi.Input['ControllerImageArgs']] = None,
                 node_selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 pod_annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 priority_class_name: Optional[pulumi.Input[builtins.str]] = None,
                 run_as_user: Optional[pulumi.Input[builtins.int]] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.TolerationArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] priority_class_name: Provide a priority class name to the webhook patching job.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if pod_annotations is not None:
            pulumi.set(__self__, "pod_annotations", pod_annotations)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['ControllerImageArgs']]:
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['ControllerImageArgs']]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "node_selector")

    @node_selector.setter
    def node_selector(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "node_selector", value)

    @property
    @pulumi.getter(name="podAnnotations")
    def pod_annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "pod_annotations")

    @pod_annotations.setter
    def pod_annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "pod_annotations", value)

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Provide a priority class name to the webhook patching job.
        """
        return pulumi.get(self, "priority_class_name")

    @priority_class_name.setter
    def priority_class_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "priority_class_name", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.TolerationArgs']]]]:
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.TolerationArgs']]]]):
        pulumi.set(self, "tolerations", value)


if not MYPY:
    class ControllerAdmissionWebhooksServiceArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        cluster_ip: NotRequired[pulumi.Input[builtins.str]]
        external_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        load_balancer_ips: NotRequired[pulumi.Input[builtins.str]]
        load_balancer_source_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        service_port: NotRequired[pulumi.Input[builtins.int]]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ControllerAdmissionWebhooksServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerAdmissionWebhooksServiceArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 cluster_ip: Optional[pulumi.Input[builtins.str]] = None,
                 external_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 load_balancer_ips: Optional[pulumi.Input[builtins.str]] = None,
                 load_balancer_source_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 service_port: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_ip is not None:
            pulumi.set(__self__, "cluster_ip", cluster_ip)
        if external_ips is not None:
            pulumi.set(__self__, "external_ips", external_ips)
        if load_balancer_ips is not None:
            pulumi.set(__self__, "load_balancer_ips", load_balancer_ips)
        if load_balancer_source_ranges is not None:
            pulumi.set(__self__, "load_balancer_source_ranges", load_balancer_source_ranges)
        if service_port is not None:
            pulumi.set(__self__, "service_port", service_port)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clusterIP")
    def cluster_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cluster_ip")

    @cluster_ip.setter
    def cluster_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_ip", value)

    @property
    @pulumi.getter(name="externalIPs")
    def external_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "external_ips")

    @external_ips.setter
    def external_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "external_ips", value)

    @property
    @pulumi.getter(name="loadBalancerIPs")
    def load_balancer_ips(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "load_balancer_ips")

    @load_balancer_ips.setter
    def load_balancer_ips(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "load_balancer_ips", value)

    @property
    @pulumi.getter(name="loadBalancerSourceRanges")
    def load_balancer_source_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "load_balancer_source_ranges")

    @load_balancer_source_ranges.setter
    def load_balancer_source_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "load_balancer_source_ranges", value)

    @property
    @pulumi.getter(name="servicePort")
    def service_port(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "service_port")

    @service_port.setter
    def service_port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "service_port", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ControllerCustomTemplateArgsDict(TypedDict):
        config_map_key: NotRequired[pulumi.Input[builtins.str]]
        config_map_name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ControllerCustomTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerCustomTemplateArgs:
    def __init__(__self__, *,
                 config_map_key: Optional[pulumi.Input[builtins.str]] = None,
                 config_map_name: Optional[pulumi.Input[builtins.str]] = None):
        if config_map_key is not None:
            pulumi.set(__self__, "config_map_key", config_map_key)
        if config_map_name is not None:
            pulumi.set(__self__, "config_map_name", config_map_name)

    @property
    @pulumi.getter(name="configMapKey")
    def config_map_key(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "config_map_key")

    @config_map_key.setter
    def config_map_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "config_map_key", value)

    @property
    @pulumi.getter(name="configMapName")
    def config_map_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "config_map_name")

    @config_map_name.setter
    def config_map_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "config_map_name", value)


if not MYPY:
    class ControllerDefaultBackendServiceArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        cluster_ip: NotRequired[pulumi.Input[builtins.str]]
        external_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of IP addresses at which the default backend service is available. Ref: https://kubernetes.io/docs/user-guide/services/#external-ips
        """
        load_balancer_ip: NotRequired[pulumi.Input[builtins.str]]
        load_balancer_source_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        service_port: NotRequired[pulumi.Input[builtins.int]]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ControllerDefaultBackendServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerDefaultBackendServiceArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 cluster_ip: Optional[pulumi.Input[builtins.str]] = None,
                 external_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 load_balancer_ip: Optional[pulumi.Input[builtins.str]] = None,
                 load_balancer_source_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 service_port: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] external_ips: List of IP addresses at which the default backend service is available. Ref: https://kubernetes.io/docs/user-guide/services/#external-ips
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_ip is not None:
            pulumi.set(__self__, "cluster_ip", cluster_ip)
        if external_ips is not None:
            pulumi.set(__self__, "external_ips", external_ips)
        if load_balancer_ip is not None:
            pulumi.set(__self__, "load_balancer_ip", load_balancer_ip)
        if load_balancer_source_ranges is not None:
            pulumi.set(__self__, "load_balancer_source_ranges", load_balancer_source_ranges)
        if service_port is not None:
            pulumi.set(__self__, "service_port", service_port)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clusterIP")
    def cluster_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cluster_ip")

    @cluster_ip.setter
    def cluster_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_ip", value)

    @property
    @pulumi.getter(name="externalIPs")
    def external_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of IP addresses at which the default backend service is available. Ref: https://kubernetes.io/docs/user-guide/services/#external-ips
        """
        return pulumi.get(self, "external_ips")

    @external_ips.setter
    def external_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "external_ips", value)

    @property
    @pulumi.getter(name="loadBalancerIP")
    def load_balancer_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "load_balancer_ip")

    @load_balancer_ip.setter
    def load_balancer_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "load_balancer_ip", value)

    @property
    @pulumi.getter(name="loadBalancerSourceRanges")
    def load_balancer_source_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "load_balancer_source_ranges")

    @load_balancer_source_ranges.setter
    def load_balancer_source_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "load_balancer_source_ranges", value)

    @property
    @pulumi.getter(name="servicePort")
    def service_port(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "service_port")

    @service_port.setter
    def service_port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "service_port", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ControllerDefaultBackendArgsDict(TypedDict):
        affinity: NotRequired[pulumi.Input['pulumi_kubernetes.core.v1.AffinityArgsDict']]
        autoscaling: NotRequired[pulumi.Input['AutoscalingArgsDict']]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        existing_psp: NotRequired[pulumi.Input[builtins.str]]
        """
        Use an existing PSP instead of creating one.
        """
        extra_args: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]
        extra_envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.EnvVarArgsDict']]]]
        extra_volume_mounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeMountArgsDict']]]]
        """
        Additional volumeMounts to the default backend container.  - name: copy-portal-skins    mountPath: /var/lib/lemonldap-ng/portal/skins
        """
        extra_volumes: NotRequired[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeArgsDict']]]]
        """
        Additional volumes to the default backend pod.  - name: copy-portal-skins    emptyDir: {}
        """
        image: NotRequired[pulumi.Input['ControllerImageArgsDict']]
        liveness_probe: NotRequired[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgsDict']]
        """
        Liveness probe values for default backend. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
        """
        min_available: NotRequired[pulumi.Input[builtins.int]]
        name: NotRequired[pulumi.Input[builtins.str]]
        node_selector: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Node labels for default backend pod assignment Ref: https://kubernetes.io/docs/user-guide/node-selection/.
        """
        pod_annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Annotations to be added to default backend pods.
        """
        pod_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        labels to add to the pod container metadata
        """
        pod_security_context: NotRequired[pulumi.Input['pulumi_kubernetes.core.v1.PodSecurityContextArgsDict']]
        """
        Security Context policies for controller pods. See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/ for notes on enabling and using sysctls.
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        priority_class_name: NotRequired[pulumi.Input[builtins.str]]
        readiness_probe: NotRequired[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgsDict']]
        """
        Readiness probe values for default backend. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
        """
        replica_count: NotRequired[pulumi.Input[builtins.int]]
        resources: NotRequired[pulumi.Input['pulumi_kubernetes.core.v1.ResourceRequirementsArgsDict']]
        service: NotRequired[pulumi.Input['ControllerDefaultBackendServiceArgsDict']]
        service_account: NotRequired[pulumi.Input['ControllerServiceAccountArgsDict']]
        tolerations: NotRequired[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.TolerationArgsDict']]]]
        """
        Node tolerations for server scheduling to nodes with taints. Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
        """
elif False:
    ControllerDefaultBackendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerDefaultBackendArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input['pulumi_kubernetes.core.v1.AffinityArgs']] = None,
                 autoscaling: Optional[pulumi.Input['AutoscalingArgs']] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 existing_psp: Optional[pulumi.Input[builtins.str]] = None,
                 extra_args: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]] = None,
                 extra_envs: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.EnvVarArgs']]]] = None,
                 extra_volume_mounts: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeMountArgs']]]] = None,
                 extra_volumes: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeArgs']]]] = None,
                 image: Optional[pulumi.Input['ControllerImageArgs']] = None,
                 liveness_probe: Optional[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs']] = None,
                 min_available: Optional[pulumi.Input[builtins.int]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 node_selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 pod_annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 pod_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 pod_security_context: Optional[pulumi.Input['pulumi_kubernetes.core.v1.PodSecurityContextArgs']] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 priority_class_name: Optional[pulumi.Input[builtins.str]] = None,
                 readiness_probe: Optional[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs']] = None,
                 replica_count: Optional[pulumi.Input[builtins.int]] = None,
                 resources: Optional[pulumi.Input['pulumi_kubernetes.core.v1.ResourceRequirementsArgs']] = None,
                 service: Optional[pulumi.Input['ControllerDefaultBackendServiceArgs']] = None,
                 service_account: Optional[pulumi.Input['ControllerServiceAccountArgs']] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.TolerationArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] existing_psp: Use an existing PSP instead of creating one.
        :param pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeMountArgs']]] extra_volume_mounts: Additional volumeMounts to the default backend container.  - name: copy-portal-skins    mountPath: /var/lib/lemonldap-ng/portal/skins
        :param pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeArgs']]] extra_volumes: Additional volumes to the default backend pod.  - name: copy-portal-skins    emptyDir: {}
        :param pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs'] liveness_probe: Liveness probe values for default backend. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] node_selector: Node labels for default backend pod assignment Ref: https://kubernetes.io/docs/user-guide/node-selection/.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] pod_annotations: Annotations to be added to default backend pods.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] pod_labels: labels to add to the pod container metadata
        :param pulumi.Input['pulumi_kubernetes.core.v1.PodSecurityContextArgs'] pod_security_context: Security Context policies for controller pods. See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/ for notes on enabling and using sysctls.
        :param pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs'] readiness_probe: Readiness probe values for default backend. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
        :param pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.TolerationArgs']]] tolerations: Node tolerations for server scheduling to nodes with taints. Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if autoscaling is not None:
            pulumi.set(__self__, "autoscaling", autoscaling)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if existing_psp is not None:
            pulumi.set(__self__, "existing_psp", existing_psp)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if extra_volume_mounts is not None:
            pulumi.set(__self__, "extra_volume_mounts", extra_volume_mounts)
        if extra_volumes is not None:
            pulumi.set(__self__, "extra_volumes", extra_volumes)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if min_available is not None:
            pulumi.set(__self__, "min_available", min_available)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if pod_annotations is not None:
            pulumi.set(__self__, "pod_annotations", pod_annotations)
        if pod_labels is not None:
            pulumi.set(__self__, "pod_labels", pod_labels)
        if pod_security_context is not None:
            pulumi.set(__self__, "pod_security_context", pod_security_context)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if replica_count is not None:
            pulumi.set(__self__, "replica_count", replica_count)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['pulumi_kubernetes.core.v1.AffinityArgs']]:
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['pulumi_kubernetes.core.v1.AffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter
    def autoscaling(self) -> Optional[pulumi.Input['AutoscalingArgs']]:
        return pulumi.get(self, "autoscaling")

    @autoscaling.setter
    def autoscaling(self, value: Optional[pulumi.Input['AutoscalingArgs']]):
        pulumi.set(self, "autoscaling", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="existingPsp")
    def existing_psp(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Use an existing PSP instead of creating one.
        """
        return pulumi.get(self, "existing_psp")

    @existing_psp.setter
    def existing_psp(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "existing_psp", value)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]:
        return pulumi.get(self, "extra_args")

    @extra_args.setter
    def extra_args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]):
        pulumi.set(self, "extra_args", value)

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.EnvVarArgs']]]]:
        return pulumi.get(self, "extra_envs")

    @extra_envs.setter
    def extra_envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.EnvVarArgs']]]]):
        pulumi.set(self, "extra_envs", value)

    @property
    @pulumi.getter(name="extraVolumeMounts")
    def extra_volume_mounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeMountArgs']]]]:
        """
        Additional volumeMounts to the default backend container.  - name: copy-portal-skins    mountPath: /var/lib/lemonldap-ng/portal/skins
        """
        return pulumi.get(self, "extra_volume_mounts")

    @extra_volume_mounts.setter
    def extra_volume_mounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeMountArgs']]]]):
        pulumi.set(self, "extra_volume_mounts", value)

    @property
    @pulumi.getter(name="extraVolumes")
    def extra_volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeArgs']]]]:
        """
        Additional volumes to the default backend pod.  - name: copy-portal-skins    emptyDir: {}
        """
        return pulumi.get(self, "extra_volumes")

    @extra_volumes.setter
    def extra_volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeArgs']]]]):
        pulumi.set(self, "extra_volumes", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['ControllerImageArgs']]:
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['ControllerImageArgs']]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs']]:
        """
        Liveness probe values for default backend. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @property
    @pulumi.getter(name="minAvailable")
    def min_available(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "min_available")

    @min_available.setter
    def min_available(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_available", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Node labels for default backend pod assignment Ref: https://kubernetes.io/docs/user-guide/node-selection/.
        """
        return pulumi.get(self, "node_selector")

    @node_selector.setter
    def node_selector(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "node_selector", value)

    @property
    @pulumi.getter(name="podAnnotations")
    def pod_annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Annotations to be added to default backend pods.
        """
        return pulumi.get(self, "pod_annotations")

    @pod_annotations.setter
    def pod_annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "pod_annotations", value)

    @property
    @pulumi.getter(name="podLabels")
    def pod_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        labels to add to the pod container metadata
        """
        return pulumi.get(self, "pod_labels")

    @pod_labels.setter
    def pod_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "pod_labels", value)

    @property
    @pulumi.getter(name="podSecurityContext")
    def pod_security_context(self) -> Optional[pulumi.Input['pulumi_kubernetes.core.v1.PodSecurityContextArgs']]:
        """
        Security Context policies for controller pods. See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/ for notes on enabling and using sysctls.
        """
        return pulumi.get(self, "pod_security_context")

    @pod_security_context.setter
    def pod_security_context(self, value: Optional[pulumi.Input['pulumi_kubernetes.core.v1.PodSecurityContextArgs']]):
        pulumi.set(self, "pod_security_context", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "priority_class_name")

    @priority_class_name.setter
    def priority_class_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "priority_class_name", value)

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs']]:
        """
        Readiness probe values for default backend. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @property
    @pulumi.getter(name="replicaCount")
    def replica_count(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "replica_count")

    @replica_count.setter
    def replica_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "replica_count", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['pulumi_kubernetes.core.v1.ResourceRequirementsArgs']]:
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['pulumi_kubernetes.core.v1.ResourceRequirementsArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input['ControllerDefaultBackendServiceArgs']]:
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input['ControllerDefaultBackendServiceArgs']]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input['ControllerServiceAccountArgs']]:
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input['ControllerServiceAccountArgs']]):
        pulumi.set(self, "service_account", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.TolerationArgs']]]]:
        """
        Node tolerations for server scheduling to nodes with taints. Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.TolerationArgs']]]]):
        pulumi.set(self, "tolerations", value)


if not MYPY:
    class ControllerHostPortPortsArgsDict(TypedDict):
        http: NotRequired[pulumi.Input[builtins.int]]
        https: NotRequired[pulumi.Input[builtins.int]]
elif False:
    ControllerHostPortPortsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerHostPortPortsArgs:
    def __init__(__self__, *,
                 http: Optional[pulumi.Input[builtins.int]] = None,
                 https: Optional[pulumi.Input[builtins.int]] = None):
        if http is not None:
            pulumi.set(__self__, "http", http)
        if https is not None:
            pulumi.set(__self__, "https", https)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def https(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "https")

    @https.setter
    def https(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "https", value)


if not MYPY:
    class ControllerHostPortArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        ports: NotRequired[pulumi.Input['ControllerHostPortPortsArgsDict']]
elif False:
    ControllerHostPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerHostPortArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 ports: Optional[pulumi.Input['ControllerHostPortPortsArgs']] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input['ControllerHostPortPortsArgs']]:
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input['ControllerHostPortPortsArgs']]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class ControllerImageArgsDict(TypedDict):
        allow_privilege_escalation: NotRequired[pulumi.Input[builtins.bool]]
        digest: NotRequired[pulumi.Input[builtins.str]]
        image: NotRequired[pulumi.Input[builtins.str]]
        pull_policy: NotRequired[pulumi.Input[builtins.str]]
        read_only_root_filesystem: NotRequired[pulumi.Input[builtins.bool]]
        registry: NotRequired[pulumi.Input[builtins.str]]
        repository: NotRequired[pulumi.Input[builtins.str]]
        """
        for backwards compatibility consider setting the full image url via the repository value below use *either* current default registry/image or repository format or installing will fail.
        """
        run_as_non_root: NotRequired[pulumi.Input[builtins.bool]]
        run_as_user: NotRequired[pulumi.Input[builtins.str]]
        tag: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ControllerImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerImageArgs:
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[pulumi.Input[builtins.bool]] = None,
                 digest: Optional[pulumi.Input[builtins.str]] = None,
                 image: Optional[pulumi.Input[builtins.str]] = None,
                 pull_policy: Optional[pulumi.Input[builtins.str]] = None,
                 read_only_root_filesystem: Optional[pulumi.Input[builtins.bool]] = None,
                 registry: Optional[pulumi.Input[builtins.str]] = None,
                 repository: Optional[pulumi.Input[builtins.str]] = None,
                 run_as_non_root: Optional[pulumi.Input[builtins.bool]] = None,
                 run_as_user: Optional[pulumi.Input[builtins.str]] = None,
                 tag: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] repository: for backwards compatibility consider setting the full image url via the repository value below use *either* current default registry/image or repository format or installing will fail.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if pull_policy is not None:
            pulumi.set(__self__, "pull_policy", pull_policy)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if registry is not None:
            pulumi.set(__self__, "registry", registry)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "allow_privilege_escalation")

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_privilege_escalation", value)

    @property
    @pulumi.getter
    def digest(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "digest")

    @digest.setter
    def digest(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "digest", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="pullPolicy")
    def pull_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "pull_policy")

    @pull_policy.setter
    def pull_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pull_policy", value)

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "read_only_root_filesystem")

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "read_only_root_filesystem", value)

    @property
    @pulumi.getter
    def registry(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "registry")

    @registry.setter
    def registry(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "registry", value)

    @property
    @pulumi.getter
    def repository(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        for backwards compatibility consider setting the full image url via the repository value below use *either* current default registry/image or repository format or installing will fail.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repository", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class ControllerIngressClassResourceArgsDict(TypedDict):
        controller_value: NotRequired[pulumi.Input[builtins.str]]
        default: NotRequired[pulumi.Input[builtins.bool]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        name: NotRequired[pulumi.Input[builtins.str]]
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]
        """
        Parameters is a link to a custom resource containing additional configuration for the controller. This is optional if the controller does not require extra parameters.
        """
elif False:
    ControllerIngressClassResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerIngressClassResourceArgs:
    def __init__(__self__, *,
                 controller_value: Optional[pulumi.Input[builtins.str]] = None,
                 default: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]] parameters: Parameters is a link to a custom resource containing additional configuration for the controller. This is optional if the controller does not require extra parameters.
        """
        if controller_value is not None:
            pulumi.set(__self__, "controller_value", controller_value)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="controllerValue")
    def controller_value(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "controller_value")

    @controller_value.setter
    def controller_value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "controller_value", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]:
        """
        Parameters is a link to a custom resource containing additional configuration for the controller. This is optional if the controller does not require extra parameters.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class ControllerMetricsPrometheusRulesArgsDict(TypedDict):
        additional_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        namespace: NotRequired[pulumi.Input[builtins.str]]
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]
elif False:
    ControllerMetricsPrometheusRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerMetricsPrometheusRulesArgs:
    def __init__(__self__, *,
                 additional_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 namespace: Optional[pulumi.Input[builtins.str]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]] = None):
        if additional_labels is not None:
            pulumi.set(__self__, "additional_labels", additional_labels)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="additionalLabels")
    def additional_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "additional_labels")

    @additional_labels.setter
    def additional_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "additional_labels", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class ControllerMetricsServiceMonitorArgsDict(TypedDict):
        additional_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        honor_labels: NotRequired[pulumi.Input[builtins.bool]]
        job_label: NotRequired[pulumi.Input[builtins.str]]
        """
        The label to use to retrieve the job name from.
        """
        metric_relabelings: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        namespace: NotRequired[pulumi.Input[builtins.str]]
        namespace_selector: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]
        scrape_interval: NotRequired[pulumi.Input[builtins.str]]
        target_labels: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    ControllerMetricsServiceMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerMetricsServiceMonitorArgs:
    def __init__(__self__, *,
                 additional_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 honor_labels: Optional[pulumi.Input[builtins.bool]] = None,
                 job_label: Optional[pulumi.Input[builtins.str]] = None,
                 metric_relabelings: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 namespace: Optional[pulumi.Input[builtins.str]] = None,
                 namespace_selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]] = None,
                 scrape_interval: Optional[pulumi.Input[builtins.str]] = None,
                 target_labels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] job_label: The label to use to retrieve the job name from.
        """
        if additional_labels is not None:
            pulumi.set(__self__, "additional_labels", additional_labels)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if honor_labels is not None:
            pulumi.set(__self__, "honor_labels", honor_labels)
        if job_label is not None:
            pulumi.set(__self__, "job_label", job_label)
        if metric_relabelings is not None:
            pulumi.set(__self__, "metric_relabelings", metric_relabelings)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if namespace_selector is not None:
            pulumi.set(__self__, "namespace_selector", namespace_selector)
        if scrape_interval is not None:
            pulumi.set(__self__, "scrape_interval", scrape_interval)
        if target_labels is not None:
            pulumi.set(__self__, "target_labels", target_labels)

    @property
    @pulumi.getter(name="additionalLabels")
    def additional_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "additional_labels")

    @additional_labels.setter
    def additional_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "additional_labels", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="honorLabels")
    def honor_labels(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "honor_labels")

    @honor_labels.setter
    def honor_labels(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "honor_labels", value)

    @property
    @pulumi.getter(name="jobLabel")
    def job_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The label to use to retrieve the job name from.
        """
        return pulumi.get(self, "job_label")

    @job_label.setter
    def job_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "job_label", value)

    @property
    @pulumi.getter(name="metricRelabelings")
    def metric_relabelings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "metric_relabelings")

    @metric_relabelings.setter
    def metric_relabelings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "metric_relabelings", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="namespaceSelector")
    def namespace_selector(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]:
        return pulumi.get(self, "namespace_selector")

    @namespace_selector.setter
    def namespace_selector(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]):
        pulumi.set(self, "namespace_selector", value)

    @property
    @pulumi.getter(name="scrapeInterval")
    def scrape_interval(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "scrape_interval")

    @scrape_interval.setter
    def scrape_interval(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "scrape_interval", value)

    @property
    @pulumi.getter(name="targetLabels")
    def target_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "target_labels")

    @target_labels.setter
    def target_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "target_labels", value)


if not MYPY:
    class ControllerMetricsServiceArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        cluster_ip: NotRequired[pulumi.Input[builtins.str]]
        external_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        external_traffic_policy: NotRequired[pulumi.Input[builtins.str]]
        load_balancer_ips: NotRequired[pulumi.Input[builtins.str]]
        load_balancer_source_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        node_port: NotRequired[pulumi.Input[builtins.str]]
        service_port: NotRequired[pulumi.Input[builtins.int]]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ControllerMetricsServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerMetricsServiceArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 cluster_ip: Optional[pulumi.Input[builtins.str]] = None,
                 external_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 external_traffic_policy: Optional[pulumi.Input[builtins.str]] = None,
                 load_balancer_ips: Optional[pulumi.Input[builtins.str]] = None,
                 load_balancer_source_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 node_port: Optional[pulumi.Input[builtins.str]] = None,
                 service_port: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_ip is not None:
            pulumi.set(__self__, "cluster_ip", cluster_ip)
        if external_ips is not None:
            pulumi.set(__self__, "external_ips", external_ips)
        if external_traffic_policy is not None:
            pulumi.set(__self__, "external_traffic_policy", external_traffic_policy)
        if load_balancer_ips is not None:
            pulumi.set(__self__, "load_balancer_ips", load_balancer_ips)
        if load_balancer_source_ranges is not None:
            pulumi.set(__self__, "load_balancer_source_ranges", load_balancer_source_ranges)
        if node_port is not None:
            pulumi.set(__self__, "node_port", node_port)
        if service_port is not None:
            pulumi.set(__self__, "service_port", service_port)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clusterIP")
    def cluster_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cluster_ip")

    @cluster_ip.setter
    def cluster_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_ip", value)

    @property
    @pulumi.getter(name="externalIPs")
    def external_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "external_ips")

    @external_ips.setter
    def external_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "external_ips", value)

    @property
    @pulumi.getter(name="externalTrafficPolicy")
    def external_traffic_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "external_traffic_policy")

    @external_traffic_policy.setter
    def external_traffic_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_traffic_policy", value)

    @property
    @pulumi.getter(name="loadBalancerIPs")
    def load_balancer_ips(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "load_balancer_ips")

    @load_balancer_ips.setter
    def load_balancer_ips(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "load_balancer_ips", value)

    @property
    @pulumi.getter(name="loadBalancerSourceRanges")
    def load_balancer_source_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "load_balancer_source_ranges")

    @load_balancer_source_ranges.setter
    def load_balancer_source_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "load_balancer_source_ranges", value)

    @property
    @pulumi.getter(name="nodePort")
    def node_port(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "node_port")

    @node_port.setter
    def node_port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "node_port", value)

    @property
    @pulumi.getter(name="servicePort")
    def service_port(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "service_port")

    @service_port.setter
    def service_port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "service_port", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ControllerMetricsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        if this port is changed, change healthz-port: in extraArgs: accordingly.
        """
        prometheus_rule: NotRequired[pulumi.Input['ControllerMetricsPrometheusRulesArgsDict']]
        service: NotRequired[pulumi.Input['ControllerMetricsServiceArgsDict']]
        service_monitor: NotRequired[pulumi.Input['ControllerMetricsServiceMonitorArgsDict']]
elif False:
    ControllerMetricsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerMetricsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 prometheus_rule: Optional[pulumi.Input['ControllerMetricsPrometheusRulesArgs']] = None,
                 service: Optional[pulumi.Input['ControllerMetricsServiceArgs']] = None,
                 service_monitor: Optional[pulumi.Input['ControllerMetricsServiceMonitorArgs']] = None):
        """
        :param pulumi.Input[builtins.int] port: if this port is changed, change healthz-port: in extraArgs: accordingly.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if prometheus_rule is not None:
            pulumi.set(__self__, "prometheus_rule", prometheus_rule)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if service_monitor is not None:
            pulumi.set(__self__, "service_monitor", service_monitor)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        if this port is changed, change healthz-port: in extraArgs: accordingly.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="prometheusRule")
    def prometheus_rule(self) -> Optional[pulumi.Input['ControllerMetricsPrometheusRulesArgs']]:
        return pulumi.get(self, "prometheus_rule")

    @prometheus_rule.setter
    def prometheus_rule(self, value: Optional[pulumi.Input['ControllerMetricsPrometheusRulesArgs']]):
        pulumi.set(self, "prometheus_rule", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input['ControllerMetricsServiceArgs']]:
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input['ControllerMetricsServiceArgs']]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="serviceMonitor")
    def service_monitor(self) -> Optional[pulumi.Input['ControllerMetricsServiceMonitorArgs']]:
        return pulumi.get(self, "service_monitor")

    @service_monitor.setter
    def service_monitor(self, value: Optional[pulumi.Input['ControllerMetricsServiceMonitorArgs']]):
        pulumi.set(self, "service_monitor", value)


if not MYPY:
    class ControllerPodSecurityPolicyArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    ControllerPodSecurityPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerPodSecurityPolicyArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ControllerPortArgsDict(TypedDict):
        http: NotRequired[pulumi.Input[builtins.int]]
        https: NotRequired[pulumi.Input[builtins.int]]
elif False:
    ControllerPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerPortArgs:
    def __init__(__self__, *,
                 http: Optional[pulumi.Input[builtins.int]] = None,
                 https: Optional[pulumi.Input[builtins.int]] = None):
        if http is not None:
            pulumi.set(__self__, "http", http)
        if https is not None:
            pulumi.set(__self__, "https", https)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def https(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "https")

    @https.setter
    def https(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "https", value)


if not MYPY:
    class ControllerPublishServiceArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        path_override: NotRequired[pulumi.Input[builtins.str]]
        """
        Allows overriding of the publish service to bind to. Must be <namespace>/<service_name>.
        """
elif False:
    ControllerPublishServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerPublishServiceArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 path_override: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] path_override: Allows overriding of the publish service to bind to. Must be <namespace>/<service_name>.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if path_override is not None:
            pulumi.set(__self__, "path_override", path_override)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="pathOverride")
    def path_override(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Allows overriding of the publish service to bind to. Must be <namespace>/<service_name>.
        """
        return pulumi.get(self, "path_override")

    @path_override.setter
    def path_override(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path_override", value)


if not MYPY:
    class ControllerRBACArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.bool]]
        scope: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    ControllerRBACArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerRBACArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.bool]] = None,
                 scope: Optional[pulumi.Input[builtins.bool]] = None):
        if create is not None:
            pulumi.set(__self__, "create", create)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class ControllerRollingUpdateArgsDict(TypedDict):
        max_unavailable: NotRequired[pulumi.Input[builtins.int]]
elif False:
    ControllerRollingUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerRollingUpdateArgs:
    def __init__(__self__, *,
                 max_unavailable: Optional[pulumi.Input[builtins.int]] = None):
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_unavailable", value)


if not MYPY:
    class ControllerScopeArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        namespace: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ControllerScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerScopeArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 namespace: Optional[pulumi.Input[builtins.str]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class ControllerServiceAccountArgsDict(TypedDict):
        automount_service_account_token: NotRequired[pulumi.Input[builtins.bool]]
        create: NotRequired[pulumi.Input[builtins.bool]]
        name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ControllerServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerServiceAccountArgs:
    def __init__(__self__, *,
                 automount_service_account_token: Optional[pulumi.Input[builtins.bool]] = None,
                 create: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        if automount_service_account_token is not None:
            pulumi.set(__self__, "automount_service_account_token", automount_service_account_token)
        if create is not None:
            pulumi.set(__self__, "create", create)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="automountServiceAccountToken")
    def automount_service_account_token(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "automount_service_account_token")

    @automount_service_account_token.setter
    def automount_service_account_token(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "automount_service_account_token", value)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ControllerServiceInternalArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        external_traffic_policy: NotRequired[pulumi.Input[builtins.str]]
        """
        Set external traffic policy to: "Local" to preserve source IP on providers supporting it. Ref: https://kubernetes.io/docs/tutorials/services/source-ip/#source-ip-for-services-with-typeloadbalancer
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        load_balancer_ips: NotRequired[pulumi.Input[builtins.str]]
        load_balancer_source_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Restrict access For LoadBalancer service. Defaults to 0.0.0.0/0.
        """
elif False:
    ControllerServiceInternalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerServiceInternalArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 external_traffic_policy: Optional[pulumi.Input[builtins.str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 load_balancer_ips: Optional[pulumi.Input[builtins.str]] = None,
                 load_balancer_source_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] external_traffic_policy: Set external traffic policy to: "Local" to preserve source IP on providers supporting it. Ref: https://kubernetes.io/docs/tutorials/services/source-ip/#source-ip-for-services-with-typeloadbalancer
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] load_balancer_source_ranges: Restrict access For LoadBalancer service. Defaults to 0.0.0.0/0.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if external_traffic_policy is not None:
            pulumi.set(__self__, "external_traffic_policy", external_traffic_policy)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if load_balancer_ips is not None:
            pulumi.set(__self__, "load_balancer_ips", load_balancer_ips)
        if load_balancer_source_ranges is not None:
            pulumi.set(__self__, "load_balancer_source_ranges", load_balancer_source_ranges)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="externalTrafficPolicy")
    def external_traffic_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Set external traffic policy to: "Local" to preserve source IP on providers supporting it. Ref: https://kubernetes.io/docs/tutorials/services/source-ip/#source-ip-for-services-with-typeloadbalancer
        """
        return pulumi.get(self, "external_traffic_policy")

    @external_traffic_policy.setter
    def external_traffic_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_traffic_policy", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="loadBalancerIPs")
    def load_balancer_ips(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "load_balancer_ips")

    @load_balancer_ips.setter
    def load_balancer_ips(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "load_balancer_ips", value)

    @property
    @pulumi.getter(name="loadBalancerSourceRanges")
    def load_balancer_source_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Restrict access For LoadBalancer service. Defaults to 0.0.0.0/0.
        """
        return pulumi.get(self, "load_balancer_source_ranges")

    @load_balancer_source_ranges.setter
    def load_balancer_source_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "load_balancer_source_ranges", value)


if not MYPY:
    class ControllerServiceNodePortsArgsDict(TypedDict):
        http: NotRequired[pulumi.Input[builtins.str]]
        https: NotRequired[pulumi.Input[builtins.str]]
        tcp: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]
        udp: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]
elif False:
    ControllerServiceNodePortsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerServiceNodePortsArgs:
    def __init__(__self__, *,
                 http: Optional[pulumi.Input[builtins.str]] = None,
                 https: Optional[pulumi.Input[builtins.str]] = None,
                 tcp: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]] = None,
                 udp: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]] = None):
        if http is not None:
            pulumi.set(__self__, "http", http)
        if https is not None:
            pulumi.set(__self__, "https", https)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def https(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "https")

    @https.setter
    def https(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "https", value)

    @property
    @pulumi.getter
    def tcp(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]:
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]):
        pulumi.set(self, "tcp", value)

    @property
    @pulumi.getter
    def udp(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]:
        return pulumi.get(self, "udp")

    @udp.setter
    def udp(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]):
        pulumi.set(self, "udp", value)


if not MYPY:
    class ControllerServiceArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        cluster_ip: NotRequired[pulumi.Input[builtins.str]]
        enable_http: NotRequired[pulumi.Input[builtins.bool]]
        enable_https: NotRequired[pulumi.Input[builtins.bool]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        external_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of IP addresses at which the controller services are available Ref: https://kubernetes.io/docs/user-guide/services/#external-ips
        """
        external_traffic_policy: NotRequired[pulumi.Input[builtins.str]]
        """
        Set external traffic policy to: "Local" to preserve source IP on providers supporting it. Ref: https://kubernetes.io/docs/tutorials/services/source-ip/#source-ip-for-services-with-typeloadbalancer
        """
        health_check_node_port: NotRequired[pulumi.Input[builtins.int]]
        """
        specifies the health check node port (numeric port number) for the service. If healthCheckNodePort isnt specified, the service controller allocates a port from your clusters NodePort range. Ref: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip
        """
        internal: NotRequired[pulumi.Input['ControllerServiceInternalArgsDict']]
        """
        Enables an additional internal load balancer (besides the external one). Annotations are mandatory for the load balancer to come up. Varies with the cloud service.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        load_balancer_ip: NotRequired[pulumi.Input[builtins.str]]
        load_balancer_ips: NotRequired[pulumi.Input[builtins.str]]
        load_balancer_source_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        node_ports: NotRequired[pulumi.Input['ControllerServiceNodePortsArgsDict']]
        ports: NotRequired[pulumi.Input['ControllerPortArgsDict']]
        session_affinity: NotRequired[pulumi.Input[builtins.str]]
        """
        Must be either "None" or "ClientIP" if set. Kubernetes will default to "None". Ref: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        """
        target_ports: NotRequired[pulumi.Input['ControllerPortArgsDict']]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ControllerServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerServiceArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 cluster_ip: Optional[pulumi.Input[builtins.str]] = None,
                 enable_http: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_https: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 external_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 external_traffic_policy: Optional[pulumi.Input[builtins.str]] = None,
                 health_check_node_port: Optional[pulumi.Input[builtins.int]] = None,
                 internal: Optional[pulumi.Input['ControllerServiceInternalArgs']] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 load_balancer_ip: Optional[pulumi.Input[builtins.str]] = None,
                 load_balancer_ips: Optional[pulumi.Input[builtins.str]] = None,
                 load_balancer_source_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 node_ports: Optional[pulumi.Input['ControllerServiceNodePortsArgs']] = None,
                 ports: Optional[pulumi.Input['ControllerPortArgs']] = None,
                 session_affinity: Optional[pulumi.Input[builtins.str]] = None,
                 target_ports: Optional[pulumi.Input['ControllerPortArgs']] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] external_ips: List of IP addresses at which the controller services are available Ref: https://kubernetes.io/docs/user-guide/services/#external-ips
        :param pulumi.Input[builtins.str] external_traffic_policy: Set external traffic policy to: "Local" to preserve source IP on providers supporting it. Ref: https://kubernetes.io/docs/tutorials/services/source-ip/#source-ip-for-services-with-typeloadbalancer
        :param pulumi.Input[builtins.int] health_check_node_port: specifies the health check node port (numeric port number) for the service. If healthCheckNodePort isnt specified, the service controller allocates a port from your clusters NodePort range. Ref: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip
        :param pulumi.Input['ControllerServiceInternalArgs'] internal: Enables an additional internal load balancer (besides the external one). Annotations are mandatory for the load balancer to come up. Varies with the cloud service.
        :param pulumi.Input[builtins.str] session_affinity: Must be either "None" or "ClientIP" if set. Kubernetes will default to "None". Ref: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_ip is not None:
            pulumi.set(__self__, "cluster_ip", cluster_ip)
        if enable_http is not None:
            pulumi.set(__self__, "enable_http", enable_http)
        if enable_https is not None:
            pulumi.set(__self__, "enable_https", enable_https)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if external_ips is not None:
            pulumi.set(__self__, "external_ips", external_ips)
        if external_traffic_policy is not None:
            pulumi.set(__self__, "external_traffic_policy", external_traffic_policy)
        if health_check_node_port is not None:
            pulumi.set(__self__, "health_check_node_port", health_check_node_port)
        if internal is not None:
            pulumi.set(__self__, "internal", internal)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if load_balancer_ip is not None:
            pulumi.set(__self__, "load_balancer_ip", load_balancer_ip)
        if load_balancer_ips is not None:
            pulumi.set(__self__, "load_balancer_ips", load_balancer_ips)
        if load_balancer_source_ranges is not None:
            pulumi.set(__self__, "load_balancer_source_ranges", load_balancer_source_ranges)
        if node_ports is not None:
            pulumi.set(__self__, "node_ports", node_ports)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if session_affinity is not None:
            pulumi.set(__self__, "session_affinity", session_affinity)
        if target_ports is not None:
            pulumi.set(__self__, "target_ports", target_ports)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clusterIP")
    def cluster_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cluster_ip")

    @cluster_ip.setter
    def cluster_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_ip", value)

    @property
    @pulumi.getter(name="enableHttp")
    def enable_http(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enable_http")

    @enable_http.setter
    def enable_http(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_http", value)

    @property
    @pulumi.getter(name="enableHttps")
    def enable_https(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enable_https")

    @enable_https.setter
    def enable_https(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_https", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="externalIPs")
    def external_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of IP addresses at which the controller services are available Ref: https://kubernetes.io/docs/user-guide/services/#external-ips
        """
        return pulumi.get(self, "external_ips")

    @external_ips.setter
    def external_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "external_ips", value)

    @property
    @pulumi.getter(name="externalTrafficPolicy")
    def external_traffic_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Set external traffic policy to: "Local" to preserve source IP on providers supporting it. Ref: https://kubernetes.io/docs/tutorials/services/source-ip/#source-ip-for-services-with-typeloadbalancer
        """
        return pulumi.get(self, "external_traffic_policy")

    @external_traffic_policy.setter
    def external_traffic_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_traffic_policy", value)

    @property
    @pulumi.getter(name="healthCheckNodePort")
    def health_check_node_port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        specifies the health check node port (numeric port number) for the service. If healthCheckNodePort isnt specified, the service controller allocates a port from your clusters NodePort range. Ref: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip
        """
        return pulumi.get(self, "health_check_node_port")

    @health_check_node_port.setter
    def health_check_node_port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "health_check_node_port", value)

    @property
    @pulumi.getter
    def internal(self) -> Optional[pulumi.Input['ControllerServiceInternalArgs']]:
        """
        Enables an additional internal load balancer (besides the external one). Annotations are mandatory for the load balancer to come up. Varies with the cloud service.
        """
        return pulumi.get(self, "internal")

    @internal.setter
    def internal(self, value: Optional[pulumi.Input['ControllerServiceInternalArgs']]):
        pulumi.set(self, "internal", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="loadBalancerIP")
    def load_balancer_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "load_balancer_ip")

    @load_balancer_ip.setter
    def load_balancer_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "load_balancer_ip", value)

    @property
    @pulumi.getter(name="loadBalancerIPs")
    def load_balancer_ips(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "load_balancer_ips")

    @load_balancer_ips.setter
    def load_balancer_ips(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "load_balancer_ips", value)

    @property
    @pulumi.getter(name="loadBalancerSourceRanges")
    def load_balancer_source_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "load_balancer_source_ranges")

    @load_balancer_source_ranges.setter
    def load_balancer_source_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "load_balancer_source_ranges", value)

    @property
    @pulumi.getter(name="nodePorts")
    def node_ports(self) -> Optional[pulumi.Input['ControllerServiceNodePortsArgs']]:
        return pulumi.get(self, "node_ports")

    @node_ports.setter
    def node_ports(self, value: Optional[pulumi.Input['ControllerServiceNodePortsArgs']]):
        pulumi.set(self, "node_ports", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input['ControllerPortArgs']]:
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input['ControllerPortArgs']]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter(name="sessionAffinity")
    def session_affinity(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Must be either "None" or "ClientIP" if set. Kubernetes will default to "None". Ref: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        """
        return pulumi.get(self, "session_affinity")

    @session_affinity.setter
    def session_affinity(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "session_affinity", value)

    @property
    @pulumi.getter(name="targetPorts")
    def target_ports(self) -> Optional[pulumi.Input['ControllerPortArgs']]:
        return pulumi.get(self, "target_ports")

    @target_ports.setter
    def target_ports(self, value: Optional[pulumi.Input['ControllerPortArgs']]):
        pulumi.set(self, "target_ports", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ControllerTcpArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Annotations to be added to the tcp config configmap.
        """
        config_map_namespace: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ControllerTcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerTcpArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 config_map_namespace: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] annotations: Annotations to be added to the tcp config configmap.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if config_map_namespace is not None:
            pulumi.set(__self__, "config_map_namespace", config_map_namespace)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Annotations to be added to the tcp config configmap.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="configMapNamespace")
    def config_map_namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "config_map_namespace")

    @config_map_namespace.setter
    def config_map_namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "config_map_namespace", value)


if not MYPY:
    class ControllerUdpArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Annotations to be added to the udp config configmap.
        """
        config_map_namespace: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ControllerUdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerUdpArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 config_map_namespace: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] annotations: Annotations to be added to the udp config configmap.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if config_map_namespace is not None:
            pulumi.set(__self__, "config_map_namespace", config_map_namespace)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Annotations to be added to the udp config configmap.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="configMapNamespace")
    def config_map_namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "config_map_namespace")

    @config_map_namespace.setter
    def config_map_namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "config_map_namespace", value)


if not MYPY:
    class ControllerUpdateStrategyArgsDict(TypedDict):
        rolling_update: NotRequired[pulumi.Input['ControllerRollingUpdateArgsDict']]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ControllerUpdateStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerUpdateStrategyArgs:
    def __init__(__self__, *,
                 rolling_update: Optional[pulumi.Input['ControllerRollingUpdateArgs']] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional[pulumi.Input['ControllerRollingUpdateArgs']]:
        return pulumi.get(self, "rolling_update")

    @rolling_update.setter
    def rolling_update(self, value: Optional[pulumi.Input['ControllerRollingUpdateArgs']]):
        pulumi.set(self, "rolling_update", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ControllerArgsDict(TypedDict):
        add_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]
        """
        Will add custom headers before sending response traffic to the client according to: https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#add-headers.
        """
        admission_webhooks: NotRequired[pulumi.Input['ContollerAdmissionWebhooksArgsDict']]
        affinity: NotRequired[pulumi.Input['pulumi_kubernetes.core.v1.AffinityArgsDict']]
        """
        Affinity and anti-affinity Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity.
        """
        allow_snippet_annotations: NotRequired[pulumi.Input[builtins.bool]]
        """
        This configuration defines if Ingress Controller should allow users to set their own *-snippet annotations, otherwise this is forbidden / dropped when users add those annotations. Global snippets in ConfigMap are still respected.
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Annotations to be added to the controller Deployment or DaemonSet.
        """
        autoscaling: NotRequired[pulumi.Input['AutoscalingArgsDict']]
        """
        Mutually exclusive with keda autoscaling.
        """
        autoscaling_template: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutoscalingTemplateArgsDict']]]]
        """
        Custom or additional autoscaling metrics ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#support-for-custom-metrics
        """
        config: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Will add custom configuration options to Nginx https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/.
        """
        config_annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Annotations to be added to the controller config configuration configmap.
        """
        config_map_namespace: NotRequired[pulumi.Input[builtins.str]]
        """
        Allows customization of the configmap / nginx-configmap namespace.
        """
        container_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Configures the controller container name.
        """
        container_port: NotRequired[pulumi.Input['ControllerPortArgsDict']]
        """
        Configures the ports the nginx-controller listens on.
        """
        custom_template: NotRequired[pulumi.Input['ControllerCustomTemplateArgsDict']]
        """
        Override NGINX template.
        """
        dns_config: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Optionally customize the pod dnsConfig.
        """
        dns_policy: NotRequired[pulumi.Input[builtins.str]]
        """
        Optionally change this to ClusterFirstWithHostNet in case you have 'hostNetwork: true'. By default, while using host network, name resolution uses the host's DNS. If you wish nginx-controller to keep resolving names inside the k8s network, use ClusterFirstWithHostNet.
        """
        election_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Election ID to use for status update.
        """
        enable_mimalloc: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable mimalloc as a drop-in replacement for malloc. ref: https://github.com/microsoft/mimalloc.
        """
        existing_psp: NotRequired[pulumi.Input[builtins.str]]
        """
        Use an existing PSP instead of creating one.
        """
        extra_args: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Additional command line arguments to pass to nginx-ingress-controller E.g. to specify the default SSL certificate you can use `default-ssl-certificate: "<namespace>/<secret_name>"`.
        """
        extra_containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.ContainerArgsDict']]]]
        """
        Additional containers to be added to the controller pod. See https://github.com/lemonldap-ng-controller/lemonldap-ng-controller as example.
        """
        extra_envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.EnvVarArgsDict']]]]
        """
        Additional environment variables to set.
        """
        extra_init_containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.ContainerArgsDict']]]]
        """
        Containers, which are run before the app containers are started. - name: init-myservice   image: busybox   command: ['sh', '-c', 'until nslookup myservice; do echo waiting for myservice; sleep 2; done;']
        """
        extra_volume_mounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeMountArgsDict']]]]
        """
        Additional volumeMounts to the controller main container.  - name: copy-portal-skins    mountPath: /var/lib/lemonldap-ng/portal/skins
        """
        extra_volumes: NotRequired[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeArgsDict']]]]
        """
        Additional volumes to the controller pod.  - name: copy-portal-skins    emptyDir: {}
        """
        health_check_path: NotRequired[pulumi.Input[builtins.str]]
        """
        Path of the health check endpoint. All requests received on the port defined by the healthz-port parameter are forwarded internally to this path.
        """
        heath_check_host: NotRequired[pulumi.Input[builtins.str]]
        """
        Address to bind the health check endpoint. It is better to set this option to the internal node address if the ingress nginx controller is running in the hostNetwork: true mode.
        """
        host_network: NotRequired[pulumi.Input[builtins.bool]]
        """
        Required for use with CNI based kubernetes installations (such as ones set up by kubeadm), since CNI and hostport don't mix yet. Can be deprecated once https://github.com/kubernetes/kubernetes/issues/23920 is merged.
        """
        host_port: NotRequired[pulumi.Input['ControllerHostPortArgsDict']]
        """
        Use host ports 80 and 443. Disabled by default.
        """
        hostname: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]
        """
        Optionally customize the pod hostname.
        """
        image: NotRequired[pulumi.Input['ControllerImageArgsDict']]
        ingress_class_by_name: NotRequired[pulumi.Input[builtins.bool]]
        """
        Process IngressClass per name (additionally as per spec.controller).
        """
        ingress_class_resource: NotRequired[pulumi.Input['ControllerIngressClassResourceArgsDict']]
        """
        This section refers to the creation of the IngressClass resource. IngressClass resources are supported since k8s >= 1.18 and required since k8s >= 1.19
        """
        keda: NotRequired[pulumi.Input['KedaArgsDict']]
        """
        Mutually exclusive with hpa autoscaling.
        """
        kind: NotRequired[pulumi.Input[builtins.str]]
        """
        DaemonSet or Deployment.
        """
        lifecycle: NotRequired[pulumi.Input['pulumi_kubernetes.core.v1.LifecycleArgsDict']]
        """
        Improve connection draining when ingress controller pod is deleted using a lifecycle hook: With this new hook, we increased the default terminationGracePeriodSeconds from 30 seconds to 300, allowing the draining of connections up to five minutes. If the active connections end before that, the pod will terminate gracefully at that time. To effectively take advantage of this feature, the Configmap feature worker-shutdown-timeout new value is 240s instead of 10s.
        """
        liveness_probe: NotRequired[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgsDict']]
        """
        Liveness probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
        """
        maxmind_license_key: NotRequired[pulumi.Input[builtins.str]]
        """
        Maxmind license key to download GeoLite2 Databases https://blog.maxmind.com/2019/12/18/significant-changes-to-accessing-and-using-geolite2-databases.
        """
        metrics: NotRequired[pulumi.Input['ControllerMetricsArgsDict']]
        min_available: NotRequired[pulumi.Input[builtins.int]]
        min_ready_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        minReadySeconds to avoid killing pods before we are ready.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        node_selector: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Node labels for controller pod assignment Ref: https://kubernetes.io/docs/user-guide/node-selection/.
        """
        pod_annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Annotations to be added to controller pods.
        """
        pod_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        labels to add to the pod container metadata.
        """
        pod_security_context: NotRequired[pulumi.Input['pulumi_kubernetes.core.v1.PodSecurityContextArgsDict']]
        """
        Security Context policies for controller pods.
        """
        priority_class_name: NotRequired[pulumi.Input[builtins.str]]
        proxy_set_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]
        """
        Will add custom headers before sending traffic to backends according to https://github.com/kubernetes/ingress-nginx/tree/main/docs/examples/customization/custom-headers.
        """
        publish_service: NotRequired[pulumi.Input['ControllerPublishServiceArgsDict']]
        """
        Allows customization of the source of the IP address or FQDN to report in the ingress status field. By default, it reads the information provided by the service. If disable, the status field reports the IP address of the node or nodes where an ingress controller pod is running.
        """
        readiness_probe: NotRequired[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgsDict']]
        """
        Readiness probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
        """
        replica_count: NotRequired[pulumi.Input[builtins.int]]
        report_node_internal_ip: NotRequired[pulumi.Input[builtins.bool]]
        """
        Bare-metal considerations via the host network https://kubernetes.github.io/ingress-nginx/deploy/baremetal/#via-the-host-network Ingress status was blank because there is no Service exposing the NGINX Ingress controller in a configuration using the host network, the default --publish-service flag used in standard cloud setups does not apply.
        """
        resources: NotRequired[pulumi.Input['pulumi_kubernetes.core.v1.ResourceRequirementsArgsDict']]
        """
        Define requests resources to avoid probe issues due to CPU utilization in busy nodes ref: https://github.com/kubernetes/ingress-nginx/issues/4735#issuecomment-551204903 Ideally, there should be no limits. https://engineering.indeedblog.com/blog/2019/12/cpu-throttling-regression-fix/
        """
        scope: NotRequired[pulumi.Input['ControllerScopeArgsDict']]
        """
        Limit the scope of the controller.
        """
        service: NotRequired[pulumi.Input['ControllerServiceArgsDict']]
        startup_probe: NotRequired[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgsDict']]
        """
        Startup probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
        """
        sysctls: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]
        """
        See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/ for notes on enabling and using sysctls.
        """
        tcp: NotRequired[pulumi.Input['ControllerTcpArgsDict']]
        """
        Allows customization of the tcp-services-configmap.
        """
        terminate_grace_period_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        How long to wait for the drain of connections.
        """
        tolerations: NotRequired[pulumi.Input['pulumi_kubernetes.core.v1.TolerationArgsDict']]
        """
        Node tolerations for server scheduling to nodes with taints Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/.
        """
        topology_spread_constraints: NotRequired[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.TopologySpreadConstraintArgsDict']]]]
        """
        Topology spread constraints rely on node labels to identify the topology domain(s) that each Node is in. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/.
        """
        udp: NotRequired[pulumi.Input['ControllerUdpArgsDict']]
        update_strategy: NotRequired[pulumi.Input['ControllerUpdateStrategyArgsDict']]
        """
        The update strategy to apply to the Deployment or DaemonSet.
        """
        watch_ingress_without_class: NotRequired[pulumi.Input[builtins.bool]]
        """
        Process Ingress objects without ingressClass annotation/ingressClassName field. Overrides value for --watch-ingress-without-class flag of the controller binary. Defaults to false.
        """
elif False:
    ControllerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControllerArgs:
    def __init__(__self__, *,
                 add_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]] = None,
                 admission_webhooks: Optional[pulumi.Input['ContollerAdmissionWebhooksArgs']] = None,
                 affinity: Optional[pulumi.Input['pulumi_kubernetes.core.v1.AffinityArgs']] = None,
                 allow_snippet_annotations: Optional[pulumi.Input[builtins.bool]] = None,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 autoscaling: Optional[pulumi.Input['AutoscalingArgs']] = None,
                 autoscaling_template: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingTemplateArgs']]]] = None,
                 config: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 config_annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 config_map_namespace: Optional[pulumi.Input[builtins.str]] = None,
                 container_name: Optional[pulumi.Input[builtins.str]] = None,
                 container_port: Optional[pulumi.Input['ControllerPortArgs']] = None,
                 custom_template: Optional[pulumi.Input['ControllerCustomTemplateArgs']] = None,
                 dns_config: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 dns_policy: Optional[pulumi.Input[builtins.str]] = None,
                 election_id: Optional[pulumi.Input[builtins.str]] = None,
                 enable_mimalloc: Optional[pulumi.Input[builtins.bool]] = None,
                 existing_psp: Optional[pulumi.Input[builtins.str]] = None,
                 extra_args: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 extra_containers: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.ContainerArgs']]]] = None,
                 extra_envs: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.EnvVarArgs']]]] = None,
                 extra_init_containers: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.ContainerArgs']]]] = None,
                 extra_volume_mounts: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeMountArgs']]]] = None,
                 extra_volumes: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeArgs']]]] = None,
                 health_check_path: Optional[pulumi.Input[builtins.str]] = None,
                 heath_check_host: Optional[pulumi.Input[builtins.str]] = None,
                 host_network: Optional[pulumi.Input[builtins.bool]] = None,
                 host_port: Optional[pulumi.Input['ControllerHostPortArgs']] = None,
                 hostname: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]] = None,
                 image: Optional[pulumi.Input['ControllerImageArgs']] = None,
                 ingress_class_by_name: Optional[pulumi.Input[builtins.bool]] = None,
                 ingress_class_resource: Optional[pulumi.Input['ControllerIngressClassResourceArgs']] = None,
                 keda: Optional[pulumi.Input['KedaArgs']] = None,
                 kind: Optional[pulumi.Input[builtins.str]] = None,
                 lifecycle: Optional[pulumi.Input['pulumi_kubernetes.core.v1.LifecycleArgs']] = None,
                 liveness_probe: Optional[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs']] = None,
                 maxmind_license_key: Optional[pulumi.Input[builtins.str]] = None,
                 metrics: Optional[pulumi.Input['ControllerMetricsArgs']] = None,
                 min_available: Optional[pulumi.Input[builtins.int]] = None,
                 min_ready_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 node_selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 pod_annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 pod_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 pod_security_context: Optional[pulumi.Input['pulumi_kubernetes.core.v1.PodSecurityContextArgs']] = None,
                 priority_class_name: Optional[pulumi.Input[builtins.str]] = None,
                 proxy_set_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]] = None,
                 publish_service: Optional[pulumi.Input['ControllerPublishServiceArgs']] = None,
                 readiness_probe: Optional[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs']] = None,
                 replica_count: Optional[pulumi.Input[builtins.int]] = None,
                 report_node_internal_ip: Optional[pulumi.Input[builtins.bool]] = None,
                 resources: Optional[pulumi.Input['pulumi_kubernetes.core.v1.ResourceRequirementsArgs']] = None,
                 scope: Optional[pulumi.Input['ControllerScopeArgs']] = None,
                 service: Optional[pulumi.Input['ControllerServiceArgs']] = None,
                 startup_probe: Optional[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs']] = None,
                 sysctls: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]] = None,
                 tcp: Optional[pulumi.Input['ControllerTcpArgs']] = None,
                 terminate_grace_period_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 tolerations: Optional[pulumi.Input['pulumi_kubernetes.core.v1.TolerationArgs']] = None,
                 topology_spread_constraints: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.TopologySpreadConstraintArgs']]]] = None,
                 udp: Optional[pulumi.Input['ControllerUdpArgs']] = None,
                 update_strategy: Optional[pulumi.Input['ControllerUpdateStrategyArgs']] = None,
                 watch_ingress_without_class: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]] add_headers: Will add custom headers before sending response traffic to the client according to: https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#add-headers.
        :param pulumi.Input['pulumi_kubernetes.core.v1.AffinityArgs'] affinity: Affinity and anti-affinity Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity.
        :param pulumi.Input[builtins.bool] allow_snippet_annotations: This configuration defines if Ingress Controller should allow users to set their own *-snippet annotations, otherwise this is forbidden / dropped when users add those annotations. Global snippets in ConfigMap are still respected.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] annotations: Annotations to be added to the controller Deployment or DaemonSet.
        :param pulumi.Input['AutoscalingArgs'] autoscaling: Mutually exclusive with keda autoscaling.
        :param pulumi.Input[Sequence[pulumi.Input['AutoscalingTemplateArgs']]] autoscaling_template: Custom or additional autoscaling metrics ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#support-for-custom-metrics
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] config: Will add custom configuration options to Nginx https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] config_annotations: Annotations to be added to the controller config configuration configmap.
        :param pulumi.Input[builtins.str] config_map_namespace: Allows customization of the configmap / nginx-configmap namespace.
        :param pulumi.Input[builtins.str] container_name: Configures the controller container name.
        :param pulumi.Input['ControllerPortArgs'] container_port: Configures the ports the nginx-controller listens on.
        :param pulumi.Input['ControllerCustomTemplateArgs'] custom_template: Override NGINX template.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] dns_config: Optionally customize the pod dnsConfig.
        :param pulumi.Input[builtins.str] dns_policy: Optionally change this to ClusterFirstWithHostNet in case you have 'hostNetwork: true'. By default, while using host network, name resolution uses the host's DNS. If you wish nginx-controller to keep resolving names inside the k8s network, use ClusterFirstWithHostNet.
        :param pulumi.Input[builtins.str] election_id: Election ID to use for status update.
        :param pulumi.Input[builtins.bool] enable_mimalloc: Enable mimalloc as a drop-in replacement for malloc. ref: https://github.com/microsoft/mimalloc.
        :param pulumi.Input[builtins.str] existing_psp: Use an existing PSP instead of creating one.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] extra_args: Additional command line arguments to pass to nginx-ingress-controller E.g. to specify the default SSL certificate you can use `default-ssl-certificate: "<namespace>/<secret_name>"`.
        :param pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.ContainerArgs']]] extra_containers: Additional containers to be added to the controller pod. See https://github.com/lemonldap-ng-controller/lemonldap-ng-controller as example.
        :param pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.EnvVarArgs']]] extra_envs: Additional environment variables to set.
        :param pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.ContainerArgs']]] extra_init_containers: Containers, which are run before the app containers are started. - name: init-myservice   image: busybox   command: ['sh', '-c', 'until nslookup myservice; do echo waiting for myservice; sleep 2; done;']
        :param pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeMountArgs']]] extra_volume_mounts: Additional volumeMounts to the controller main container.  - name: copy-portal-skins    mountPath: /var/lib/lemonldap-ng/portal/skins
        :param pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeArgs']]] extra_volumes: Additional volumes to the controller pod.  - name: copy-portal-skins    emptyDir: {}
        :param pulumi.Input[builtins.str] health_check_path: Path of the health check endpoint. All requests received on the port defined by the healthz-port parameter are forwarded internally to this path.
        :param pulumi.Input[builtins.str] heath_check_host: Address to bind the health check endpoint. It is better to set this option to the internal node address if the ingress nginx controller is running in the hostNetwork: true mode.
        :param pulumi.Input[builtins.bool] host_network: Required for use with CNI based kubernetes installations (such as ones set up by kubeadm), since CNI and hostport don't mix yet. Can be deprecated once https://github.com/kubernetes/kubernetes/issues/23920 is merged.
        :param pulumi.Input['ControllerHostPortArgs'] host_port: Use host ports 80 and 443. Disabled by default.
        :param pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]] hostname: Optionally customize the pod hostname.
        :param pulumi.Input[builtins.bool] ingress_class_by_name: Process IngressClass per name (additionally as per spec.controller).
        :param pulumi.Input['ControllerIngressClassResourceArgs'] ingress_class_resource: This section refers to the creation of the IngressClass resource. IngressClass resources are supported since k8s >= 1.18 and required since k8s >= 1.19
        :param pulumi.Input['KedaArgs'] keda: Mutually exclusive with hpa autoscaling.
        :param pulumi.Input[builtins.str] kind: DaemonSet or Deployment.
        :param pulumi.Input['pulumi_kubernetes.core.v1.LifecycleArgs'] lifecycle: Improve connection draining when ingress controller pod is deleted using a lifecycle hook: With this new hook, we increased the default terminationGracePeriodSeconds from 30 seconds to 300, allowing the draining of connections up to five minutes. If the active connections end before that, the pod will terminate gracefully at that time. To effectively take advantage of this feature, the Configmap feature worker-shutdown-timeout new value is 240s instead of 10s.
        :param pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs'] liveness_probe: Liveness probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
        :param pulumi.Input[builtins.str] maxmind_license_key: Maxmind license key to download GeoLite2 Databases https://blog.maxmind.com/2019/12/18/significant-changes-to-accessing-and-using-geolite2-databases.
        :param pulumi.Input[builtins.int] min_ready_seconds: minReadySeconds to avoid killing pods before we are ready.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] node_selector: Node labels for controller pod assignment Ref: https://kubernetes.io/docs/user-guide/node-selection/.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] pod_annotations: Annotations to be added to controller pods.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] pod_labels: labels to add to the pod container metadata.
        :param pulumi.Input['pulumi_kubernetes.core.v1.PodSecurityContextArgs'] pod_security_context: Security Context policies for controller pods.
        :param pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]] proxy_set_headers: Will add custom headers before sending traffic to backends according to https://github.com/kubernetes/ingress-nginx/tree/main/docs/examples/customization/custom-headers.
        :param pulumi.Input['ControllerPublishServiceArgs'] publish_service: Allows customization of the source of the IP address or FQDN to report in the ingress status field. By default, it reads the information provided by the service. If disable, the status field reports the IP address of the node or nodes where an ingress controller pod is running.
        :param pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs'] readiness_probe: Readiness probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
        :param pulumi.Input[builtins.bool] report_node_internal_ip: Bare-metal considerations via the host network https://kubernetes.github.io/ingress-nginx/deploy/baremetal/#via-the-host-network Ingress status was blank because there is no Service exposing the NGINX Ingress controller in a configuration using the host network, the default --publish-service flag used in standard cloud setups does not apply.
        :param pulumi.Input['pulumi_kubernetes.core.v1.ResourceRequirementsArgs'] resources: Define requests resources to avoid probe issues due to CPU utilization in busy nodes ref: https://github.com/kubernetes/ingress-nginx/issues/4735#issuecomment-551204903 Ideally, there should be no limits. https://engineering.indeedblog.com/blog/2019/12/cpu-throttling-regression-fix/
        :param pulumi.Input['ControllerScopeArgs'] scope: Limit the scope of the controller.
        :param pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs'] startup_probe: Startup probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
        :param pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]] sysctls: See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/ for notes on enabling and using sysctls.
        :param pulumi.Input['ControllerTcpArgs'] tcp: Allows customization of the tcp-services-configmap.
        :param pulumi.Input[builtins.int] terminate_grace_period_seconds: How long to wait for the drain of connections.
        :param pulumi.Input['pulumi_kubernetes.core.v1.TolerationArgs'] tolerations: Node tolerations for server scheduling to nodes with taints Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/.
        :param pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.TopologySpreadConstraintArgs']]] topology_spread_constraints: Topology spread constraints rely on node labels to identify the topology domain(s) that each Node is in. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/.
        :param pulumi.Input['ControllerUpdateStrategyArgs'] update_strategy: The update strategy to apply to the Deployment or DaemonSet.
        :param pulumi.Input[builtins.bool] watch_ingress_without_class: Process Ingress objects without ingressClass annotation/ingressClassName field. Overrides value for --watch-ingress-without-class flag of the controller binary. Defaults to false.
        """
        if add_headers is not None:
            pulumi.set(__self__, "add_headers", add_headers)
        if admission_webhooks is not None:
            pulumi.set(__self__, "admission_webhooks", admission_webhooks)
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if allow_snippet_annotations is not None:
            pulumi.set(__self__, "allow_snippet_annotations", allow_snippet_annotations)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if autoscaling is not None:
            pulumi.set(__self__, "autoscaling", autoscaling)
        if autoscaling_template is not None:
            pulumi.set(__self__, "autoscaling_template", autoscaling_template)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if config_annotations is not None:
            pulumi.set(__self__, "config_annotations", config_annotations)
        if config_map_namespace is not None:
            pulumi.set(__self__, "config_map_namespace", config_map_namespace)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if container_port is not None:
            pulumi.set(__self__, "container_port", container_port)
        if custom_template is not None:
            pulumi.set(__self__, "custom_template", custom_template)
        if dns_config is not None:
            pulumi.set(__self__, "dns_config", dns_config)
        if dns_policy is not None:
            pulumi.set(__self__, "dns_policy", dns_policy)
        if election_id is not None:
            pulumi.set(__self__, "election_id", election_id)
        if enable_mimalloc is not None:
            pulumi.set(__self__, "enable_mimalloc", enable_mimalloc)
        if existing_psp is not None:
            pulumi.set(__self__, "existing_psp", existing_psp)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_containers is not None:
            pulumi.set(__self__, "extra_containers", extra_containers)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if extra_init_containers is not None:
            pulumi.set(__self__, "extra_init_containers", extra_init_containers)
        if extra_volume_mounts is not None:
            pulumi.set(__self__, "extra_volume_mounts", extra_volume_mounts)
        if extra_volumes is not None:
            pulumi.set(__self__, "extra_volumes", extra_volumes)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if heath_check_host is not None:
            pulumi.set(__self__, "heath_check_host", heath_check_host)
        if host_network is not None:
            pulumi.set(__self__, "host_network", host_network)
        if host_port is not None:
            pulumi.set(__self__, "host_port", host_port)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if ingress_class_by_name is not None:
            pulumi.set(__self__, "ingress_class_by_name", ingress_class_by_name)
        if ingress_class_resource is not None:
            pulumi.set(__self__, "ingress_class_resource", ingress_class_resource)
        if keda is not None:
            pulumi.set(__self__, "keda", keda)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if maxmind_license_key is not None:
            pulumi.set(__self__, "maxmind_license_key", maxmind_license_key)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if min_available is not None:
            pulumi.set(__self__, "min_available", min_available)
        if min_ready_seconds is not None:
            pulumi.set(__self__, "min_ready_seconds", min_ready_seconds)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if pod_annotations is not None:
            pulumi.set(__self__, "pod_annotations", pod_annotations)
        if pod_labels is not None:
            pulumi.set(__self__, "pod_labels", pod_labels)
        if pod_security_context is not None:
            pulumi.set(__self__, "pod_security_context", pod_security_context)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if proxy_set_headers is not None:
            pulumi.set(__self__, "proxy_set_headers", proxy_set_headers)
        if publish_service is not None:
            pulumi.set(__self__, "publish_service", publish_service)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if replica_count is not None:
            pulumi.set(__self__, "replica_count", replica_count)
        if report_node_internal_ip is not None:
            pulumi.set(__self__, "report_node_internal_ip", report_node_internal_ip)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if startup_probe is not None:
            pulumi.set(__self__, "startup_probe", startup_probe)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if terminate_grace_period_seconds is not None:
            pulumi.set(__self__, "terminate_grace_period_seconds", terminate_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if topology_spread_constraints is not None:
            pulumi.set(__self__, "topology_spread_constraints", topology_spread_constraints)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)
        if watch_ingress_without_class is not None:
            pulumi.set(__self__, "watch_ingress_without_class", watch_ingress_without_class)

    @property
    @pulumi.getter(name="addHeaders")
    def add_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]:
        """
        Will add custom headers before sending response traffic to the client according to: https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#add-headers.
        """
        return pulumi.get(self, "add_headers")

    @add_headers.setter
    def add_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]):
        pulumi.set(self, "add_headers", value)

    @property
    @pulumi.getter(name="admissionWebhooks")
    def admission_webhooks(self) -> Optional[pulumi.Input['ContollerAdmissionWebhooksArgs']]:
        return pulumi.get(self, "admission_webhooks")

    @admission_webhooks.setter
    def admission_webhooks(self, value: Optional[pulumi.Input['ContollerAdmissionWebhooksArgs']]):
        pulumi.set(self, "admission_webhooks", value)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['pulumi_kubernetes.core.v1.AffinityArgs']]:
        """
        Affinity and anti-affinity Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['pulumi_kubernetes.core.v1.AffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter(name="allowSnippetAnnotations")
    def allow_snippet_annotations(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        This configuration defines if Ingress Controller should allow users to set their own *-snippet annotations, otherwise this is forbidden / dropped when users add those annotations. Global snippets in ConfigMap are still respected.
        """
        return pulumi.get(self, "allow_snippet_annotations")

    @allow_snippet_annotations.setter
    def allow_snippet_annotations(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_snippet_annotations", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Annotations to be added to the controller Deployment or DaemonSet.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def autoscaling(self) -> Optional[pulumi.Input['AutoscalingArgs']]:
        """
        Mutually exclusive with keda autoscaling.
        """
        return pulumi.get(self, "autoscaling")

    @autoscaling.setter
    def autoscaling(self, value: Optional[pulumi.Input['AutoscalingArgs']]):
        pulumi.set(self, "autoscaling", value)

    @property
    @pulumi.getter(name="autoscalingTemplate")
    def autoscaling_template(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingTemplateArgs']]]]:
        """
        Custom or additional autoscaling metrics ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#support-for-custom-metrics
        """
        return pulumi.get(self, "autoscaling_template")

    @autoscaling_template.setter
    def autoscaling_template(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingTemplateArgs']]]]):
        pulumi.set(self, "autoscaling_template", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Will add custom configuration options to Nginx https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter(name="configAnnotations")
    def config_annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Annotations to be added to the controller config configuration configmap.
        """
        return pulumi.get(self, "config_annotations")

    @config_annotations.setter
    def config_annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "config_annotations", value)

    @property
    @pulumi.getter(name="configMapNamespace")
    def config_map_namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Allows customization of the configmap / nginx-configmap namespace.
        """
        return pulumi.get(self, "config_map_namespace")

    @config_map_namespace.setter
    def config_map_namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "config_map_namespace", value)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Configures the controller container name.
        """
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "container_name", value)

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> Optional[pulumi.Input['ControllerPortArgs']]:
        """
        Configures the ports the nginx-controller listens on.
        """
        return pulumi.get(self, "container_port")

    @container_port.setter
    def container_port(self, value: Optional[pulumi.Input['ControllerPortArgs']]):
        pulumi.set(self, "container_port", value)

    @property
    @pulumi.getter(name="customTemplate")
    def custom_template(self) -> Optional[pulumi.Input['ControllerCustomTemplateArgs']]:
        """
        Override NGINX template.
        """
        return pulumi.get(self, "custom_template")

    @custom_template.setter
    def custom_template(self, value: Optional[pulumi.Input['ControllerCustomTemplateArgs']]):
        pulumi.set(self, "custom_template", value)

    @property
    @pulumi.getter(name="dnsConfig")
    def dns_config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Optionally customize the pod dnsConfig.
        """
        return pulumi.get(self, "dns_config")

    @dns_config.setter
    def dns_config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns_config", value)

    @property
    @pulumi.getter(name="dnsPolicy")
    def dns_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optionally change this to ClusterFirstWithHostNet in case you have 'hostNetwork: true'. By default, while using host network, name resolution uses the host's DNS. If you wish nginx-controller to keep resolving names inside the k8s network, use ClusterFirstWithHostNet.
        """
        return pulumi.get(self, "dns_policy")

    @dns_policy.setter
    def dns_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dns_policy", value)

    @property
    @pulumi.getter(name="electionID")
    def election_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Election ID to use for status update.
        """
        return pulumi.get(self, "election_id")

    @election_id.setter
    def election_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "election_id", value)

    @property
    @pulumi.getter(name="enableMimalloc")
    def enable_mimalloc(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable mimalloc as a drop-in replacement for malloc. ref: https://github.com/microsoft/mimalloc.
        """
        return pulumi.get(self, "enable_mimalloc")

    @enable_mimalloc.setter
    def enable_mimalloc(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_mimalloc", value)

    @property
    @pulumi.getter(name="existingPsp")
    def existing_psp(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Use an existing PSP instead of creating one.
        """
        return pulumi.get(self, "existing_psp")

    @existing_psp.setter
    def existing_psp(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "existing_psp", value)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Additional command line arguments to pass to nginx-ingress-controller E.g. to specify the default SSL certificate you can use `default-ssl-certificate: "<namespace>/<secret_name>"`.
        """
        return pulumi.get(self, "extra_args")

    @extra_args.setter
    def extra_args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "extra_args", value)

    @property
    @pulumi.getter(name="extraContainers")
    def extra_containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.ContainerArgs']]]]:
        """
        Additional containers to be added to the controller pod. See https://github.com/lemonldap-ng-controller/lemonldap-ng-controller as example.
        """
        return pulumi.get(self, "extra_containers")

    @extra_containers.setter
    def extra_containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.ContainerArgs']]]]):
        pulumi.set(self, "extra_containers", value)

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.EnvVarArgs']]]]:
        """
        Additional environment variables to set.
        """
        return pulumi.get(self, "extra_envs")

    @extra_envs.setter
    def extra_envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.EnvVarArgs']]]]):
        pulumi.set(self, "extra_envs", value)

    @property
    @pulumi.getter(name="extraInitContainers")
    def extra_init_containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.ContainerArgs']]]]:
        """
        Containers, which are run before the app containers are started. - name: init-myservice   image: busybox   command: ['sh', '-c', 'until nslookup myservice; do echo waiting for myservice; sleep 2; done;']
        """
        return pulumi.get(self, "extra_init_containers")

    @extra_init_containers.setter
    def extra_init_containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.ContainerArgs']]]]):
        pulumi.set(self, "extra_init_containers", value)

    @property
    @pulumi.getter(name="extraVolumeMounts")
    def extra_volume_mounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeMountArgs']]]]:
        """
        Additional volumeMounts to the controller main container.  - name: copy-portal-skins    mountPath: /var/lib/lemonldap-ng/portal/skins
        """
        return pulumi.get(self, "extra_volume_mounts")

    @extra_volume_mounts.setter
    def extra_volume_mounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeMountArgs']]]]):
        pulumi.set(self, "extra_volume_mounts", value)

    @property
    @pulumi.getter(name="extraVolumes")
    def extra_volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeArgs']]]]:
        """
        Additional volumes to the controller pod.  - name: copy-portal-skins    emptyDir: {}
        """
        return pulumi.get(self, "extra_volumes")

    @extra_volumes.setter
    def extra_volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.VolumeArgs']]]]):
        pulumi.set(self, "extra_volumes", value)

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Path of the health check endpoint. All requests received on the port defined by the healthz-port parameter are forwarded internally to this path.
        """
        return pulumi.get(self, "health_check_path")

    @health_check_path.setter
    def health_check_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "health_check_path", value)

    @property
    @pulumi.getter(name="heathCheckHost")
    def heath_check_host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Address to bind the health check endpoint. It is better to set this option to the internal node address if the ingress nginx controller is running in the hostNetwork: true mode.
        """
        return pulumi.get(self, "heath_check_host")

    @heath_check_host.setter
    def heath_check_host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "heath_check_host", value)

    @property
    @pulumi.getter(name="hostNetwork")
    def host_network(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Required for use with CNI based kubernetes installations (such as ones set up by kubeadm), since CNI and hostport don't mix yet. Can be deprecated once https://github.com/kubernetes/kubernetes/issues/23920 is merged.
        """
        return pulumi.get(self, "host_network")

    @host_network.setter
    def host_network(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "host_network", value)

    @property
    @pulumi.getter(name="hostPort")
    def host_port(self) -> Optional[pulumi.Input['ControllerHostPortArgs']]:
        """
        Use host ports 80 and 443. Disabled by default.
        """
        return pulumi.get(self, "host_port")

    @host_port.setter
    def host_port(self, value: Optional[pulumi.Input['ControllerHostPortArgs']]):
        pulumi.set(self, "host_port", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]:
        """
        Optionally customize the pod hostname.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['ControllerImageArgs']]:
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['ControllerImageArgs']]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="ingressClassByName")
    def ingress_class_by_name(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Process IngressClass per name (additionally as per spec.controller).
        """
        return pulumi.get(self, "ingress_class_by_name")

    @ingress_class_by_name.setter
    def ingress_class_by_name(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ingress_class_by_name", value)

    @property
    @pulumi.getter(name="ingressClassResource")
    def ingress_class_resource(self) -> Optional[pulumi.Input['ControllerIngressClassResourceArgs']]:
        """
        This section refers to the creation of the IngressClass resource. IngressClass resources are supported since k8s >= 1.18 and required since k8s >= 1.19
        """
        return pulumi.get(self, "ingress_class_resource")

    @ingress_class_resource.setter
    def ingress_class_resource(self, value: Optional[pulumi.Input['ControllerIngressClassResourceArgs']]):
        pulumi.set(self, "ingress_class_resource", value)

    @property
    @pulumi.getter
    def keda(self) -> Optional[pulumi.Input['KedaArgs']]:
        """
        Mutually exclusive with hpa autoscaling.
        """
        return pulumi.get(self, "keda")

    @keda.setter
    def keda(self, value: Optional[pulumi.Input['KedaArgs']]):
        pulumi.set(self, "keda", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        DaemonSet or Deployment.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def lifecycle(self) -> Optional[pulumi.Input['pulumi_kubernetes.core.v1.LifecycleArgs']]:
        """
        Improve connection draining when ingress controller pod is deleted using a lifecycle hook: With this new hook, we increased the default terminationGracePeriodSeconds from 30 seconds to 300, allowing the draining of connections up to five minutes. If the active connections end before that, the pod will terminate gracefully at that time. To effectively take advantage of this feature, the Configmap feature worker-shutdown-timeout new value is 240s instead of 10s.
        """
        return pulumi.get(self, "lifecycle")

    @lifecycle.setter
    def lifecycle(self, value: Optional[pulumi.Input['pulumi_kubernetes.core.v1.LifecycleArgs']]):
        pulumi.set(self, "lifecycle", value)

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs']]:
        """
        Liveness probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @property
    @pulumi.getter(name="maxmindLicenseKey")
    def maxmind_license_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Maxmind license key to download GeoLite2 Databases https://blog.maxmind.com/2019/12/18/significant-changes-to-accessing-and-using-geolite2-databases.
        """
        return pulumi.get(self, "maxmind_license_key")

    @maxmind_license_key.setter
    def maxmind_license_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "maxmind_license_key", value)

    @property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input['ControllerMetricsArgs']]:
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input['ControllerMetricsArgs']]):
        pulumi.set(self, "metrics", value)

    @property
    @pulumi.getter(name="minAvailable")
    def min_available(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "min_available")

    @min_available.setter
    def min_available(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_available", value)

    @property
    @pulumi.getter(name="minReadySeconds")
    def min_ready_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        minReadySeconds to avoid killing pods before we are ready.
        """
        return pulumi.get(self, "min_ready_seconds")

    @min_ready_seconds.setter
    def min_ready_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_ready_seconds", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Node labels for controller pod assignment Ref: https://kubernetes.io/docs/user-guide/node-selection/.
        """
        return pulumi.get(self, "node_selector")

    @node_selector.setter
    def node_selector(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "node_selector", value)

    @property
    @pulumi.getter(name="podAnnotations")
    def pod_annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Annotations to be added to controller pods.
        """
        return pulumi.get(self, "pod_annotations")

    @pod_annotations.setter
    def pod_annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "pod_annotations", value)

    @property
    @pulumi.getter(name="podLabels")
    def pod_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        labels to add to the pod container metadata.
        """
        return pulumi.get(self, "pod_labels")

    @pod_labels.setter
    def pod_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "pod_labels", value)

    @property
    @pulumi.getter(name="podSecurityContext")
    def pod_security_context(self) -> Optional[pulumi.Input['pulumi_kubernetes.core.v1.PodSecurityContextArgs']]:
        """
        Security Context policies for controller pods.
        """
        return pulumi.get(self, "pod_security_context")

    @pod_security_context.setter
    def pod_security_context(self, value: Optional[pulumi.Input['pulumi_kubernetes.core.v1.PodSecurityContextArgs']]):
        pulumi.set(self, "pod_security_context", value)

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "priority_class_name")

    @priority_class_name.setter
    def priority_class_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "priority_class_name", value)

    @property
    @pulumi.getter(name="proxySetHeaders")
    def proxy_set_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]:
        """
        Will add custom headers before sending traffic to backends according to https://github.com/kubernetes/ingress-nginx/tree/main/docs/examples/customization/custom-headers.
        """
        return pulumi.get(self, "proxy_set_headers")

    @proxy_set_headers.setter
    def proxy_set_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]):
        pulumi.set(self, "proxy_set_headers", value)

    @property
    @pulumi.getter(name="publishService")
    def publish_service(self) -> Optional[pulumi.Input['ControllerPublishServiceArgs']]:
        """
        Allows customization of the source of the IP address or FQDN to report in the ingress status field. By default, it reads the information provided by the service. If disable, the status field reports the IP address of the node or nodes where an ingress controller pod is running.
        """
        return pulumi.get(self, "publish_service")

    @publish_service.setter
    def publish_service(self, value: Optional[pulumi.Input['ControllerPublishServiceArgs']]):
        pulumi.set(self, "publish_service", value)

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs']]:
        """
        Readiness probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @property
    @pulumi.getter(name="replicaCount")
    def replica_count(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "replica_count")

    @replica_count.setter
    def replica_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "replica_count", value)

    @property
    @pulumi.getter(name="reportNodeInternalIp")
    def report_node_internal_ip(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Bare-metal considerations via the host network https://kubernetes.github.io/ingress-nginx/deploy/baremetal/#via-the-host-network Ingress status was blank because there is no Service exposing the NGINX Ingress controller in a configuration using the host network, the default --publish-service flag used in standard cloud setups does not apply.
        """
        return pulumi.get(self, "report_node_internal_ip")

    @report_node_internal_ip.setter
    def report_node_internal_ip(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "report_node_internal_ip", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['pulumi_kubernetes.core.v1.ResourceRequirementsArgs']]:
        """
        Define requests resources to avoid probe issues due to CPU utilization in busy nodes ref: https://github.com/kubernetes/ingress-nginx/issues/4735#issuecomment-551204903 Ideally, there should be no limits. https://engineering.indeedblog.com/blog/2019/12/cpu-throttling-regression-fix/
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['pulumi_kubernetes.core.v1.ResourceRequirementsArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input['ControllerScopeArgs']]:
        """
        Limit the scope of the controller.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input['ControllerScopeArgs']]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input['ControllerServiceArgs']]:
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input['ControllerServiceArgs']]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="startupProbe")
    def startup_probe(self) -> Optional[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs']]:
        """
        Startup probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
        """
        return pulumi.get(self, "startup_probe")

    @startup_probe.setter
    def startup_probe(self, value: Optional[pulumi.Input['pulumi_kubernetes.core.v1.ProbeArgs']]):
        pulumi.set(self, "startup_probe", value)

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]:
        """
        See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/ for notes on enabling and using sysctls.
        """
        return pulumi.get(self, "sysctls")

    @sysctls.setter
    def sysctls(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]):
        pulumi.set(self, "sysctls", value)

    @property
    @pulumi.getter
    def tcp(self) -> Optional[pulumi.Input['ControllerTcpArgs']]:
        """
        Allows customization of the tcp-services-configmap.
        """
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional[pulumi.Input['ControllerTcpArgs']]):
        pulumi.set(self, "tcp", value)

    @property
    @pulumi.getter(name="terminateGracePeriodSeconds")
    def terminate_grace_period_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        How long to wait for the drain of connections.
        """
        return pulumi.get(self, "terminate_grace_period_seconds")

    @terminate_grace_period_seconds.setter
    def terminate_grace_period_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "terminate_grace_period_seconds", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input['pulumi_kubernetes.core.v1.TolerationArgs']]:
        """
        Node tolerations for server scheduling to nodes with taints Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/.
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input['pulumi_kubernetes.core.v1.TolerationArgs']]):
        pulumi.set(self, "tolerations", value)

    @property
    @pulumi.getter(name="topologySpreadConstraints")
    def topology_spread_constraints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.TopologySpreadConstraintArgs']]]]:
        """
        Topology spread constraints rely on node labels to identify the topology domain(s) that each Node is in. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/.
        """
        return pulumi.get(self, "topology_spread_constraints")

    @topology_spread_constraints.setter
    def topology_spread_constraints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['pulumi_kubernetes.core.v1.TopologySpreadConstraintArgs']]]]):
        pulumi.set(self, "topology_spread_constraints", value)

    @property
    @pulumi.getter
    def udp(self) -> Optional[pulumi.Input['ControllerUdpArgs']]:
        return pulumi.get(self, "udp")

    @udp.setter
    def udp(self, value: Optional[pulumi.Input['ControllerUdpArgs']]):
        pulumi.set(self, "udp", value)

    @property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional[pulumi.Input['ControllerUpdateStrategyArgs']]:
        """
        The update strategy to apply to the Deployment or DaemonSet.
        """
        return pulumi.get(self, "update_strategy")

    @update_strategy.setter
    def update_strategy(self, value: Optional[pulumi.Input['ControllerUpdateStrategyArgs']]):
        pulumi.set(self, "update_strategy", value)

    @property
    @pulumi.getter(name="watchIngressWithoutClass")
    def watch_ingress_without_class(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Process Ingress objects without ingressClass annotation/ingressClassName field. Overrides value for --watch-ingress-without-class flag of the controller binary. Defaults to false.
        """
        return pulumi.get(self, "watch_ingress_without_class")

    @watch_ingress_without_class.setter
    def watch_ingress_without_class(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "watch_ingress_without_class", value)


if not MYPY:
    class KedaScaledObjectArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Custom annotations for ScaledObject resource.
        """
elif False:
    KedaScaledObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KedaScaledObjectArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] annotations: Custom annotations for ScaledObject resource.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Custom annotations for ScaledObject resource.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "annotations", value)


if not MYPY:
    class KedaTriggerArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    KedaTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KedaTriggerArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]:
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class KedaArgsDict(TypedDict):
        api_version: NotRequired[pulumi.Input[builtins.str]]
        """
        apiVersion changes with keda 1.x vs 2.x: 2.x = keda.sh/v1alpha1, 1.x = keda.k8s.io/v1alpha1.
        """
        behavior: NotRequired[pulumi.Input['AutoscalingBehaviorArgsDict']]
        cooldown_period: NotRequired[pulumi.Input[builtins.int]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        max_replicas: NotRequired[pulumi.Input[builtins.int]]
        min_replicas: NotRequired[pulumi.Input[builtins.int]]
        polling_interval: NotRequired[pulumi.Input[builtins.int]]
        restore_to_original_replica_count: NotRequired[pulumi.Input[builtins.bool]]
        scaled_object: NotRequired[pulumi.Input['KedaScaledObjectArgsDict']]
        triggers: NotRequired[pulumi.Input[Sequence[pulumi.Input['KedaTriggerArgsDict']]]]
elif False:
    KedaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KedaArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[builtins.str]] = None,
                 behavior: Optional[pulumi.Input['AutoscalingBehaviorArgs']] = None,
                 cooldown_period: Optional[pulumi.Input[builtins.int]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 max_replicas: Optional[pulumi.Input[builtins.int]] = None,
                 min_replicas: Optional[pulumi.Input[builtins.int]] = None,
                 polling_interval: Optional[pulumi.Input[builtins.int]] = None,
                 restore_to_original_replica_count: Optional[pulumi.Input[builtins.bool]] = None,
                 scaled_object: Optional[pulumi.Input['KedaScaledObjectArgs']] = None,
                 triggers: Optional[pulumi.Input[Sequence[pulumi.Input['KedaTriggerArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] api_version: apiVersion changes with keda 1.x vs 2.x: 2.x = keda.sh/v1alpha1, 1.x = keda.k8s.io/v1alpha1.
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)
        if cooldown_period is not None:
            pulumi.set(__self__, "cooldown_period", cooldown_period)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_replicas is not None:
            pulumi.set(__self__, "max_replicas", max_replicas)
        if min_replicas is not None:
            pulumi.set(__self__, "min_replicas", min_replicas)
        if polling_interval is not None:
            pulumi.set(__self__, "polling_interval", polling_interval)
        if restore_to_original_replica_count is not None:
            pulumi.set(__self__, "restore_to_original_replica_count", restore_to_original_replica_count)
        if scaled_object is not None:
            pulumi.set(__self__, "scaled_object", scaled_object)
        if triggers is not None:
            pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        apiVersion changes with keda 1.x vs 2.x: 2.x = keda.sh/v1alpha1, 1.x = keda.k8s.io/v1alpha1.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter
    def behavior(self) -> Optional[pulumi.Input['AutoscalingBehaviorArgs']]:
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: Optional[pulumi.Input['AutoscalingBehaviorArgs']]):
        pulumi.set(self, "behavior", value)

    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "cooldown_period")

    @cooldown_period.setter
    def cooldown_period(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "cooldown_period", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max_replicas")

    @max_replicas.setter
    def max_replicas(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_replicas", value)

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "min_replicas")

    @min_replicas.setter
    def min_replicas(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_replicas", value)

    @property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "polling_interval")

    @polling_interval.setter
    def polling_interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "polling_interval", value)

    @property
    @pulumi.getter(name="restoreToOriginalReplicaCount")
    def restore_to_original_replica_count(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "restore_to_original_replica_count")

    @restore_to_original_replica_count.setter
    def restore_to_original_replica_count(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "restore_to_original_replica_count", value)

    @property
    @pulumi.getter(name="scaledObject")
    def scaled_object(self) -> Optional[pulumi.Input['KedaScaledObjectArgs']]:
        return pulumi.get(self, "scaled_object")

    @scaled_object.setter
    def scaled_object(self, value: Optional[pulumi.Input['KedaScaledObjectArgs']]):
        pulumi.set(self, "scaled_object", value)

    @property
    @pulumi.getter
    def triggers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KedaTriggerArgs']]]]:
        return pulumi.get(self, "triggers")

    @triggers.setter
    def triggers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KedaTriggerArgs']]]]):
        pulumi.set(self, "triggers", value)


if not MYPY:
    class ReleaseArgsDict(TypedDict):
        """
        A Release is an instance of a chart running in a Kubernetes cluster.
        A Chart is a Helm package. It contains all of the resource definitions necessary to run an application, tool, or service inside of a Kubernetes cluster.
        Note - Helm Release is currently in BETA and may change. Use in production environment is discouraged.
        """
        atomic: NotRequired[pulumi.Input[builtins.bool]]
        """
        If set, installation process purges chart on fail. `skipAwait` will be disabled automatically if atomic is used.
        """
        chart: NotRequired[pulumi.Input[builtins.str]]
        """
        Chart name to be installed. A path may be used.
        """
        cleanup_on_fail: NotRequired[pulumi.Input[builtins.bool]]
        """
        Allow deletion of new resources created in this upgrade when upgrade fails.
        """
        create_namespace: NotRequired[pulumi.Input[builtins.bool]]
        """
        Create the namespace if it does not exist.
        """
        dependency_update: NotRequired[pulumi.Input[builtins.bool]]
        """
        Run helm dependency update before installing the chart.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Add a custom description
        """
        devel: NotRequired[pulumi.Input[builtins.bool]]
        """
        Use chart development versions, too. Equivalent to version '>0.0.0-0'. If `version` is set, this is ignored.
        """
        disable_crd_hooks: NotRequired[pulumi.Input[builtins.bool]]
        """
        Prevent CRD hooks from, running, but run other hooks.  See helm install --no-crd-hook
        """
        disable_openapi_validation: NotRequired[pulumi.Input[builtins.bool]]
        """
        If set, the installation process will not validate rendered templates against the Kubernetes OpenAPI Schema
        """
        disable_webhooks: NotRequired[pulumi.Input[builtins.bool]]
        """
        Prevent hooks from running.
        """
        force_update: NotRequired[pulumi.Input[builtins.bool]]
        """
        Force resource update through delete/recreate if needed.
        """
        keyring: NotRequired[pulumi.Input[builtins.str]]
        """
        Location of public keys used for verification. Used only if `verify` is true
        """
        lint: NotRequired[pulumi.Input[builtins.bool]]
        """
        Run helm lint when planning.
        """
        manifest: NotRequired[pulumi.Input[Mapping[str, Any]]]
        """
        The rendered manifests as JSON. Not yet supported.
        """
        max_history: NotRequired[pulumi.Input[builtins.int]]
        """
        Limit the maximum number of revisions saved per release. Use 0 for no limit.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Release name.
        """
        namespace: NotRequired[pulumi.Input[builtins.str]]
        """
        Namespace to install the release into.
        """
        postrender: NotRequired[pulumi.Input[builtins.str]]
        """
        Postrender command to run.
        """
        recreate_pods: NotRequired[pulumi.Input[builtins.bool]]
        """
        Perform pods restart during upgrade/rollback.
        """
        render_subchart_notes: NotRequired[pulumi.Input[builtins.bool]]
        """
        If set, render subchart notes along with the parent.
        """
        replace: NotRequired[pulumi.Input[builtins.bool]]
        """
        Re-use the given name, even if that name is already used. This is unsafe in production
        """
        repository_opts: NotRequired[pulumi.Input['RepositoryOptsArgsDict']]
        """
        Specification defining the Helm chart repository to use.
        """
        reset_values: NotRequired[pulumi.Input[builtins.bool]]
        """
        When upgrading, reset the values to the ones built into the chart.
        """
        resource_names: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]]]
        """
        Names of resources created by the release grouped by "kind/version".
        """
        reuse_values: NotRequired[pulumi.Input[builtins.bool]]
        """
        When upgrading, reuse the last release's values and merge in any overrides. If 'resetValues' is specified, this is ignored
        """
        skip_await: NotRequired[pulumi.Input[builtins.bool]]
        """
        By default, the provider waits until all resources are in a ready state before marking the release as successful. Setting this to true will skip such await logic.
        """
        skip_crds: NotRequired[pulumi.Input[builtins.bool]]
        """
        If set, no CRDs will be installed. By default, CRDs are installed if not already present.
        """
        timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        Time in seconds to wait for any individual kubernetes operation.
        """
        value_yaml_files: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[pulumi.Asset, pulumi.Archive]]]]]
        """
        List of assets (raw yaml files). Content is read and merged with values. Not yet supported.
        """
        values: NotRequired[pulumi.Input[Mapping[str, Any]]]
        """
        Custom values set for the release.
        """
        verify: NotRequired[pulumi.Input[builtins.bool]]
        """
        Verify the package before installing it.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        Specify the exact chart version to install. If this is not specified, the latest version is installed.
        """
        wait_for_jobs: NotRequired[pulumi.Input[builtins.bool]]
        """
        Will wait until all Jobs have been completed before marking the release as successful. This is ignored if `skipAwait` is enabled.
        """
elif False:
    ReleaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseArgs:
    def __init__(__self__, *,
                 atomic: Optional[pulumi.Input[builtins.bool]] = None,
                 chart: Optional[pulumi.Input[builtins.str]] = None,
                 cleanup_on_fail: Optional[pulumi.Input[builtins.bool]] = None,
                 create_namespace: Optional[pulumi.Input[builtins.bool]] = None,
                 dependency_update: Optional[pulumi.Input[builtins.bool]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 devel: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_crd_hooks: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_openapi_validation: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_webhooks: Optional[pulumi.Input[builtins.bool]] = None,
                 force_update: Optional[pulumi.Input[builtins.bool]] = None,
                 keyring: Optional[pulumi.Input[builtins.str]] = None,
                 lint: Optional[pulumi.Input[builtins.bool]] = None,
                 manifest: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 max_history: Optional[pulumi.Input[builtins.int]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 namespace: Optional[pulumi.Input[builtins.str]] = None,
                 postrender: Optional[pulumi.Input[builtins.str]] = None,
                 recreate_pods: Optional[pulumi.Input[builtins.bool]] = None,
                 render_subchart_notes: Optional[pulumi.Input[builtins.bool]] = None,
                 replace: Optional[pulumi.Input[builtins.bool]] = None,
                 repository_opts: Optional[pulumi.Input['RepositoryOptsArgs']] = None,
                 reset_values: Optional[pulumi.Input[builtins.bool]] = None,
                 resource_names: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]]] = None,
                 reuse_values: Optional[pulumi.Input[builtins.bool]] = None,
                 skip_await: Optional[pulumi.Input[builtins.bool]] = None,
                 skip_crds: Optional[pulumi.Input[builtins.bool]] = None,
                 timeout: Optional[pulumi.Input[builtins.int]] = None,
                 value_yaml_files: Optional[pulumi.Input[Sequence[pulumi.Input[Union[pulumi.Asset, pulumi.Archive]]]]] = None,
                 values: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 verify: Optional[pulumi.Input[builtins.bool]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None,
                 wait_for_jobs: Optional[pulumi.Input[builtins.bool]] = None):
        """
        A Release is an instance of a chart running in a Kubernetes cluster.
        A Chart is a Helm package. It contains all of the resource definitions necessary to run an application, tool, or service inside of a Kubernetes cluster.
        Note - Helm Release is currently in BETA and may change. Use in production environment is discouraged.
        :param pulumi.Input[builtins.bool] atomic: If set, installation process purges chart on fail. `skipAwait` will be disabled automatically if atomic is used.
        :param pulumi.Input[builtins.str] chart: Chart name to be installed. A path may be used.
        :param pulumi.Input[builtins.bool] cleanup_on_fail: Allow deletion of new resources created in this upgrade when upgrade fails.
        :param pulumi.Input[builtins.bool] create_namespace: Create the namespace if it does not exist.
        :param pulumi.Input[builtins.bool] dependency_update: Run helm dependency update before installing the chart.
        :param pulumi.Input[builtins.str] description: Add a custom description
        :param pulumi.Input[builtins.bool] devel: Use chart development versions, too. Equivalent to version '>0.0.0-0'. If `version` is set, this is ignored.
        :param pulumi.Input[builtins.bool] disable_crd_hooks: Prevent CRD hooks from, running, but run other hooks.  See helm install --no-crd-hook
        :param pulumi.Input[builtins.bool] disable_openapi_validation: If set, the installation process will not validate rendered templates against the Kubernetes OpenAPI Schema
        :param pulumi.Input[builtins.bool] disable_webhooks: Prevent hooks from running.
        :param pulumi.Input[builtins.bool] force_update: Force resource update through delete/recreate if needed.
        :param pulumi.Input[builtins.str] keyring: Location of public keys used for verification. Used only if `verify` is true
        :param pulumi.Input[builtins.bool] lint: Run helm lint when planning.
        :param pulumi.Input[Mapping[str, Any]] manifest: The rendered manifests as JSON. Not yet supported.
        :param pulumi.Input[builtins.int] max_history: Limit the maximum number of revisions saved per release. Use 0 for no limit.
        :param pulumi.Input[builtins.str] name: Release name.
        :param pulumi.Input[builtins.str] namespace: Namespace to install the release into.
        :param pulumi.Input[builtins.str] postrender: Postrender command to run.
        :param pulumi.Input[builtins.bool] recreate_pods: Perform pods restart during upgrade/rollback.
        :param pulumi.Input[builtins.bool] render_subchart_notes: If set, render subchart notes along with the parent.
        :param pulumi.Input[builtins.bool] replace: Re-use the given name, even if that name is already used. This is unsafe in production
        :param pulumi.Input['RepositoryOptsArgs'] repository_opts: Specification defining the Helm chart repository to use.
        :param pulumi.Input[builtins.bool] reset_values: When upgrading, reset the values to the ones built into the chart.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]] resource_names: Names of resources created by the release grouped by "kind/version".
        :param pulumi.Input[builtins.bool] reuse_values: When upgrading, reuse the last release's values and merge in any overrides. If 'resetValues' is specified, this is ignored
        :param pulumi.Input[builtins.bool] skip_await: By default, the provider waits until all resources are in a ready state before marking the release as successful. Setting this to true will skip such await logic.
        :param pulumi.Input[builtins.bool] skip_crds: If set, no CRDs will be installed. By default, CRDs are installed if not already present.
        :param pulumi.Input[builtins.int] timeout: Time in seconds to wait for any individual kubernetes operation.
        :param pulumi.Input[Sequence[pulumi.Input[Union[pulumi.Asset, pulumi.Archive]]]] value_yaml_files: List of assets (raw yaml files). Content is read and merged with values. Not yet supported.
        :param pulumi.Input[Mapping[str, Any]] values: Custom values set for the release.
        :param pulumi.Input[builtins.bool] verify: Verify the package before installing it.
        :param pulumi.Input[builtins.str] version: Specify the exact chart version to install. If this is not specified, the latest version is installed.
        :param pulumi.Input[builtins.bool] wait_for_jobs: Will wait until all Jobs have been completed before marking the release as successful. This is ignored if `skipAwait` is enabled.
        """
        if atomic is not None:
            pulumi.set(__self__, "atomic", atomic)
        if chart is not None:
            pulumi.set(__self__, "chart", chart)
        if cleanup_on_fail is not None:
            pulumi.set(__self__, "cleanup_on_fail", cleanup_on_fail)
        if create_namespace is not None:
            pulumi.set(__self__, "create_namespace", create_namespace)
        if dependency_update is not None:
            pulumi.set(__self__, "dependency_update", dependency_update)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if devel is not None:
            pulumi.set(__self__, "devel", devel)
        if disable_crd_hooks is not None:
            pulumi.set(__self__, "disable_crd_hooks", disable_crd_hooks)
        if disable_openapi_validation is not None:
            pulumi.set(__self__, "disable_openapi_validation", disable_openapi_validation)
        if disable_webhooks is not None:
            pulumi.set(__self__, "disable_webhooks", disable_webhooks)
        if force_update is not None:
            pulumi.set(__self__, "force_update", force_update)
        if keyring is not None:
            pulumi.set(__self__, "keyring", keyring)
        if lint is not None:
            pulumi.set(__self__, "lint", lint)
        if manifest is not None:
            pulumi.set(__self__, "manifest", manifest)
        if max_history is not None:
            pulumi.set(__self__, "max_history", max_history)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if postrender is not None:
            pulumi.set(__self__, "postrender", postrender)
        if recreate_pods is not None:
            pulumi.set(__self__, "recreate_pods", recreate_pods)
        if render_subchart_notes is not None:
            pulumi.set(__self__, "render_subchart_notes", render_subchart_notes)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)
        if repository_opts is not None:
            pulumi.set(__self__, "repository_opts", repository_opts)
        if reset_values is not None:
            pulumi.set(__self__, "reset_values", reset_values)
        if resource_names is not None:
            pulumi.set(__self__, "resource_names", resource_names)
        if reuse_values is not None:
            pulumi.set(__self__, "reuse_values", reuse_values)
        if skip_await is not None:
            pulumi.set(__self__, "skip_await", skip_await)
        if skip_crds is not None:
            pulumi.set(__self__, "skip_crds", skip_crds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if value_yaml_files is not None:
            pulumi.set(__self__, "value_yaml_files", value_yaml_files)
        if values is not None:
            pulumi.set(__self__, "values", values)
        if verify is not None:
            pulumi.set(__self__, "verify", verify)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if wait_for_jobs is not None:
            pulumi.set(__self__, "wait_for_jobs", wait_for_jobs)

    @property
    @pulumi.getter
    def atomic(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If set, installation process purges chart on fail. `skipAwait` will be disabled automatically if atomic is used.
        """
        return pulumi.get(self, "atomic")

    @atomic.setter
    def atomic(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "atomic", value)

    @property
    @pulumi.getter
    def chart(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Chart name to be installed. A path may be used.
        """
        return pulumi.get(self, "chart")

    @chart.setter
    def chart(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "chart", value)

    @property
    @pulumi.getter(name="cleanupOnFail")
    def cleanup_on_fail(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Allow deletion of new resources created in this upgrade when upgrade fails.
        """
        return pulumi.get(self, "cleanup_on_fail")

    @cleanup_on_fail.setter
    def cleanup_on_fail(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "cleanup_on_fail", value)

    @property
    @pulumi.getter(name="createNamespace")
    def create_namespace(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Create the namespace if it does not exist.
        """
        return pulumi.get(self, "create_namespace")

    @create_namespace.setter
    def create_namespace(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "create_namespace", value)

    @property
    @pulumi.getter(name="dependencyUpdate")
    def dependency_update(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Run helm dependency update before installing the chart.
        """
        return pulumi.get(self, "dependency_update")

    @dependency_update.setter
    def dependency_update(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "dependency_update", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Add a custom description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def devel(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Use chart development versions, too. Equivalent to version '>0.0.0-0'. If `version` is set, this is ignored.
        """
        return pulumi.get(self, "devel")

    @devel.setter
    def devel(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "devel", value)

    @property
    @pulumi.getter(name="disableCRDHooks")
    def disable_crd_hooks(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Prevent CRD hooks from, running, but run other hooks.  See helm install --no-crd-hook
        """
        return pulumi.get(self, "disable_crd_hooks")

    @disable_crd_hooks.setter
    def disable_crd_hooks(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_crd_hooks", value)

    @property
    @pulumi.getter(name="disableOpenapiValidation")
    def disable_openapi_validation(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If set, the installation process will not validate rendered templates against the Kubernetes OpenAPI Schema
        """
        return pulumi.get(self, "disable_openapi_validation")

    @disable_openapi_validation.setter
    def disable_openapi_validation(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_openapi_validation", value)

    @property
    @pulumi.getter(name="disableWebhooks")
    def disable_webhooks(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Prevent hooks from running.
        """
        return pulumi.get(self, "disable_webhooks")

    @disable_webhooks.setter
    def disable_webhooks(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_webhooks", value)

    @property
    @pulumi.getter(name="forceUpdate")
    def force_update(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Force resource update through delete/recreate if needed.
        """
        return pulumi.get(self, "force_update")

    @force_update.setter
    def force_update(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "force_update", value)

    @property
    @pulumi.getter
    def keyring(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Location of public keys used for verification. Used only if `verify` is true
        """
        return pulumi.get(self, "keyring")

    @keyring.setter
    def keyring(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "keyring", value)

    @property
    @pulumi.getter
    def lint(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Run helm lint when planning.
        """
        return pulumi.get(self, "lint")

    @lint.setter
    def lint(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "lint", value)

    @property
    @pulumi.getter
    def manifest(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        The rendered manifests as JSON. Not yet supported.
        """
        return pulumi.get(self, "manifest")

    @manifest.setter
    def manifest(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "manifest", value)

    @property
    @pulumi.getter(name="maxHistory")
    def max_history(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Limit the maximum number of revisions saved per release. Use 0 for no limit.
        """
        return pulumi.get(self, "max_history")

    @max_history.setter
    def max_history(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_history", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Release name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Namespace to install the release into.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def postrender(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Postrender command to run.
        """
        return pulumi.get(self, "postrender")

    @postrender.setter
    def postrender(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "postrender", value)

    @property
    @pulumi.getter(name="recreatePods")
    def recreate_pods(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Perform pods restart during upgrade/rollback.
        """
        return pulumi.get(self, "recreate_pods")

    @recreate_pods.setter
    def recreate_pods(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "recreate_pods", value)

    @property
    @pulumi.getter(name="renderSubchartNotes")
    def render_subchart_notes(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If set, render subchart notes along with the parent.
        """
        return pulumi.get(self, "render_subchart_notes")

    @render_subchart_notes.setter
    def render_subchart_notes(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "render_subchart_notes", value)

    @property
    @pulumi.getter
    def replace(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Re-use the given name, even if that name is already used. This is unsafe in production
        """
        return pulumi.get(self, "replace")

    @replace.setter
    def replace(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "replace", value)

    @property
    @pulumi.getter(name="repositoryOpts")
    def repository_opts(self) -> Optional[pulumi.Input['RepositoryOptsArgs']]:
        """
        Specification defining the Helm chart repository to use.
        """
        return pulumi.get(self, "repository_opts")

    @repository_opts.setter
    def repository_opts(self, value: Optional[pulumi.Input['RepositoryOptsArgs']]):
        pulumi.set(self, "repository_opts", value)

    @property
    @pulumi.getter(name="resetValues")
    def reset_values(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When upgrading, reset the values to the ones built into the chart.
        """
        return pulumi.get(self, "reset_values")

    @reset_values.setter
    def reset_values(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "reset_values", value)

    @property
    @pulumi.getter(name="resourceNames")
    def resource_names(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]]]:
        """
        Names of resources created by the release grouped by "kind/version".
        """
        return pulumi.get(self, "resource_names")

    @resource_names.setter
    def resource_names(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]]]):
        pulumi.set(self, "resource_names", value)

    @property
    @pulumi.getter(name="reuseValues")
    def reuse_values(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When upgrading, reuse the last release's values and merge in any overrides. If 'resetValues' is specified, this is ignored
        """
        return pulumi.get(self, "reuse_values")

    @reuse_values.setter
    def reuse_values(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "reuse_values", value)

    @property
    @pulumi.getter(name="skipAwait")
    def skip_await(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        By default, the provider waits until all resources are in a ready state before marking the release as successful. Setting this to true will skip such await logic.
        """
        return pulumi.get(self, "skip_await")

    @skip_await.setter
    def skip_await(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "skip_await", value)

    @property
    @pulumi.getter(name="skipCrds")
    def skip_crds(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If set, no CRDs will be installed. By default, CRDs are installed if not already present.
        """
        return pulumi.get(self, "skip_crds")

    @skip_crds.setter
    def skip_crds(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "skip_crds", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Time in seconds to wait for any individual kubernetes operation.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="valueYamlFiles")
    def value_yaml_files(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[pulumi.Asset, pulumi.Archive]]]]]:
        """
        List of assets (raw yaml files). Content is read and merged with values. Not yet supported.
        """
        return pulumi.get(self, "value_yaml_files")

    @value_yaml_files.setter
    def value_yaml_files(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[pulumi.Asset, pulumi.Archive]]]]]):
        pulumi.set(self, "value_yaml_files", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Custom values set for the release.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def verify(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Verify the package before installing it.
        """
        return pulumi.get(self, "verify")

    @verify.setter
    def verify(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "verify", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specify the exact chart version to install. If this is not specified, the latest version is installed.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="waitForJobs")
    def wait_for_jobs(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Will wait until all Jobs have been completed before marking the release as successful. This is ignored if `skipAwait` is enabled.
        """
        return pulumi.get(self, "wait_for_jobs")

    @wait_for_jobs.setter
    def wait_for_jobs(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "wait_for_jobs", value)


if not MYPY:
    class RepositoryOptsArgsDict(TypedDict):
        """
        Specification defining the Helm chart repository to use.
        """
        ca_file: NotRequired[pulumi.Input[builtins.str]]
        """
        The Repository's CA File
        """
        cert_file: NotRequired[pulumi.Input[builtins.str]]
        """
        The repository's cert file
        """
        key_file: NotRequired[pulumi.Input[builtins.str]]
        """
        The repository's cert key file
        """
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        Password for HTTP basic authentication
        """
        repo: NotRequired[pulumi.Input[builtins.str]]
        """
        Repository where to locate the requested chart. If is a URL the chart is installed without installing the repository.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username for HTTP basic authentication
        """
elif False:
    RepositoryOptsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryOptsArgs:
    def __init__(__self__, *,
                 ca_file: Optional[pulumi.Input[builtins.str]] = None,
                 cert_file: Optional[pulumi.Input[builtins.str]] = None,
                 key_file: Optional[pulumi.Input[builtins.str]] = None,
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 repo: Optional[pulumi.Input[builtins.str]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None):
        """
        Specification defining the Helm chart repository to use.
        :param pulumi.Input[builtins.str] ca_file: The Repository's CA File
        :param pulumi.Input[builtins.str] cert_file: The repository's cert file
        :param pulumi.Input[builtins.str] key_file: The repository's cert key file
        :param pulumi.Input[builtins.str] password: Password for HTTP basic authentication
        :param pulumi.Input[builtins.str] repo: Repository where to locate the requested chart. If is a URL the chart is installed without installing the repository.
        :param pulumi.Input[builtins.str] username: Username for HTTP basic authentication
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if cert_file is not None:
            pulumi.set(__self__, "cert_file", cert_file)
        if key_file is not None:
            pulumi.set(__self__, "key_file", key_file)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Repository's CA File
        """
        return pulumi.get(self, "ca_file")

    @ca_file.setter
    def ca_file(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ca_file", value)

    @property
    @pulumi.getter(name="certFile")
    def cert_file(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The repository's cert file
        """
        return pulumi.get(self, "cert_file")

    @cert_file.setter
    def cert_file(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cert_file", value)

    @property
    @pulumi.getter(name="keyFile")
    def key_file(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The repository's cert key file
        """
        return pulumi.get(self, "key_file")

    @key_file.setter
    def key_file(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_file", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Password for HTTP basic authentication
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Repository where to locate the requested chart. If is a URL the chart is installed without installing the repository.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repo", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username for HTTP basic authentication
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)


